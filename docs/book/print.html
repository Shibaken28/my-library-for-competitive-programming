<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>shiba&#x27;s Library</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
</script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="info.html"><strong aria-hidden="true">1.</strong> このライブラリについて</a></li><li class="chapter-item expanded "><a href="tips.html"><strong aria-hidden="true">2.</strong> よくあるテクニック</a></li><li class="chapter-item expanded "><a href="cpp.html"><strong aria-hidden="true">3.</strong> C++の仕様や便利機能</a></li><li class="chapter-item expanded "><a href="wa.html"><strong aria-hidden="true">4.</strong> よくあるバグ</a></li><li class="chapter-item expanded "><a href="structure/index.html"><strong aria-hidden="true">5.</strong> データ構造</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structure/cpp.html"><strong aria-hidden="true">5.1.</strong> C++が用意しているデータ構造</a></li><li class="chapter-item expanded "><a href="structure/uf.html"><strong aria-hidden="true">5.2.</strong> UnionFind</a></li><li class="chapter-item expanded "><a href="structure/segtree.html"><strong aria-hidden="true">5.3.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="structure/lazysegtree.html"><strong aria-hidden="true">5.4.</strong> ⚠️Lazy Segment Tree</a></li><li class="chapter-item expanded "><a href="structure/BIT.html"><strong aria-hidden="true">5.5.</strong> Binary Indexed Tree</a></li></ol></li><li class="chapter-item expanded "><a href="enum/index.html"><strong aria-hidden="true">6.</strong> 列挙</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="enum/per.html"><strong aria-hidden="true">6.1.</strong> 順列組み合わせ列挙</a></li><li class="chapter-item expanded "><a href="enum/sub.html"><strong aria-hidden="true">6.2.</strong> ビットの部分集合列挙</a></li></ol></li><li class="chapter-item expanded "><a href="natural/index.html"><strong aria-hidden="true">7.</strong> 整数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="natural/prime.html"><strong aria-hidden="true">7.1.</strong> 素数判定</a></li><li class="chapter-item expanded "><a href="natural/sieve.html"><strong aria-hidden="true">7.2.</strong> 素数篩</a></li><li class="chapter-item expanded "><a href="natural/div.html"><strong aria-hidden="true">7.3.</strong> 約数列挙</a></li><li class="chapter-item expanded "><a href="natural/fac.html"><strong aria-hidden="true">7.4.</strong> 素因数分解</a></li><li class="chapter-item expanded "><a href="natural/iroot.html"><strong aria-hidden="true">7.5.</strong> 累乗根</a></li><li class="chapter-item expanded "><a href="natural/quad.html"><strong aria-hidden="true">7.6.</strong> 2次方程式</a></li><li class="chapter-item expanded "><a href="natural/pascal.html"><strong aria-hidden="true">7.7.</strong> パスカルの三角形による二項係数</a></li><li class="chapter-item expanded "><a href="natural/mint.html"><strong aria-hidden="true">7.8.</strong> modint構造体</a></li><li class="chapter-item expanded "><a href="natural/mint2.html"><strong aria-hidden="true">7.9.</strong> 実行時に法が決まるmodint構造体</a></li><li class="chapter-item expanded "><a href="natural/com.html"><strong aria-hidden="true">7.10.</strong> 二項係数(mod)</a></li><li class="chapter-item expanded "><a href="natural/lucas.html"><strong aria-hidden="true">7.11.</strong> ルーカスの定理による二項係数</a></li><li class="chapter-item expanded "><a href="natural/bezout.html"><strong aria-hidden="true">7.12.</strong> 2元1次不定方程式</a></li><li class="chapter-item expanded "><a href="natural/gcd.html"><strong aria-hidden="true">7.13.</strong> LCD,GCD</a></li><li class="chapter-item expanded "><a href="natural/crt.html"><strong aria-hidden="true">7.14.</strong> 中国剰余定理</a></li><li class="chapter-item expanded "><a href="natural/bsgs.html"><strong aria-hidden="true">7.15.</strong> baby step giant step</a></li><li class="chapter-item expanded "><a href="natural/crtg.html"><strong aria-hidden="true">7.16.</strong> ❌Garner's algorithm</a></li><li class="chapter-item expanded "><a href="natural/Tonelli.html"><strong aria-hidden="true">7.17.</strong> ❌Cipolla's algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="linear/index.html"><strong aria-hidden="true">8.</strong> 数の表現</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linear/vec3.html"><strong aria-hidden="true">8.1.</strong> 3次元ベクトル構造体</a></li><li class="chapter-item expanded "><a href="linear/matrix.html"><strong aria-hidden="true">8.2.</strong> 行列</a></li><li class="chapter-item expanded "><a href="linear/frac.html"><strong aria-hidden="true">8.3.</strong> ❌分数</a></li></ol></li><li class="chapter-item expanded "><a href="geometory/index.html"><strong aria-hidden="true">9.</strong> 幾何</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geometory/circle.html"><strong aria-hidden="true">9.1.</strong> ❌円同士の当たり判定</a></li><li class="chapter-item expanded "><a href="geometory/lineinter.html"><strong aria-hidden="true">9.2.</strong> 線分の交差判定</a></li><li class="chapter-item expanded "><a href="geometory/convex.html"><strong aria-hidden="true">9.3.</strong> ❌凸包</a></li></ol></li><li class="chapter-item expanded "><a href="seqence/index.html"><strong aria-hidden="true">10.</strong> 数列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="seqence/arith.html"><strong aria-hidden="true">10.1.</strong> 等差数列</a></li><li class="chapter-item expanded "><a href="seqence/geo.html"><strong aria-hidden="true">10.2.</strong> ❌等比数列</a></li><li class="chapter-item expanded "><a href="seqence/differ.html"><strong aria-hidden="true">10.3.</strong> ❌階差数列</a></li></ol></li><li class="chapter-item expanded "><a href="formal/index.html"><strong aria-hidden="true">11.</strong> 多項式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="uncategorized/con.html"><strong aria-hidden="true">11.1.</strong> ⚠️畳み込み</a></li><li class="chapter-item expanded "><a href="uncategorized/formal.html"><strong aria-hidden="true">11.2.</strong> ❌形式的冪級数</a></li></ol></li><li class="chapter-item expanded "><a href="string/index.html"><strong aria-hidden="true">12.</strong> 文字列</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="uncategorized/roll.html"><strong aria-hidden="true">12.1.</strong> Rolling Hash</a></li><li class="chapter-item expanded "><a href="uncategorized/Z.html"><strong aria-hidden="true">12.2.</strong> Z Algorithm</a></li><li class="chapter-item expanded "><a href="uncategorized/suffix.html"><strong aria-hidden="true">12.3.</strong> ❌sufiix array</a></li></ol></li><li class="chapter-item expanded "><a href="graph/index.html"><strong aria-hidden="true">13.</strong> グラフ理論</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph/dijkstra.html"><strong aria-hidden="true">13.1.</strong> ダイクストラ法</a></li><li class="chapter-item expanded "><a href="graph/bellman.html"><strong aria-hidden="true">13.2.</strong> ベルマンフォード法</a></li><li class="chapter-item expanded "><a href="graph/floyd.html"><strong aria-hidden="true">13.3.</strong> ワーシャルフロイド法</a></li><li class="chapter-item expanded "><a href="graph/grid.html"><strong aria-hidden="true">13.4.</strong> 2次元グリッドをグラフに起こす</a></li><li class="chapter-item expanded "><a href="graph/bi.html"><strong aria-hidden="true">13.5.</strong> 2部グラフ判定</a></li><li class="chapter-item expanded "><a href="graph/Na.html"><strong aria-hidden="true">13.6.</strong> N頂点N辺グラフ分析</a></li><li class="chapter-item expanded "><a href="graph/treel.html"><strong aria-hidden="true">13.7.</strong> 木の直径</a></li><li class="chapter-item expanded "><a href="graph/LA.html"><strong aria-hidden="true">13.8.</strong> LA</a></li><li class="chapter-item expanded "><a href="graph/LCA.html"><strong aria-hidden="true">13.9.</strong> LCA</a></li><li class="chapter-item expanded "><a href="graph/treenum.html"><strong aria-hidden="true">13.10.</strong> ⚠️木の巡回</a></li><li class="chapter-item expanded "><a href="graph/euler.html"><strong aria-hidden="true">13.11.</strong> ❌オイラーツアー</a></li><li class="chapter-item expanded "><a href="graph/cycle.html"><strong aria-hidden="true">13.12.</strong> ❌サイクル検出</a></li><li class="chapter-item expanded "><a href="graph/bridge.html"><strong aria-hidden="true">13.13.</strong> ❌橋検出</a></li><li class="chapter-item expanded "><a href="graph/art.html"><strong aria-hidden="true">13.14.</strong> ❌関節点検出</a></li><li class="chapter-item expanded "><a href="graph/bfs01.html"><strong aria-hidden="true">13.15.</strong> ❌01BFS</a></li><li class="chapter-item expanded "><a href="graph/SCC.html"><strong aria-hidden="true">13.16.</strong> ❌SCC</a></li><li class="chapter-item expanded "><a href="graph/prim.html"><strong aria-hidden="true">13.17.</strong> ❌プリム法</a></li><li class="chapter-item expanded "><a href="graph/kruskal.html"><strong aria-hidden="true">13.18.</strong> ❌クラスカル法</a></li><li class="chapter-item expanded "><a href="graph/treedp.html"><strong aria-hidden="true">13.19.</strong> ❌木dp</a></li><li class="chapter-item expanded "><a href="graph/alltreedp.html"><strong aria-hidden="true">13.20.</strong> ❌全方位木dp</a></li><li class="chapter-item expanded "><a href="graph/centroid.html"><strong aria-hidden="true">13.21.</strong> ❌重心分解</a></li><li class="chapter-item expanded "><a href="graph/flow.html"><strong aria-hidden="true">13.22.</strong> ❌最大流</a></li><li class="chapter-item expanded "><a href="graph/mincost.html"><strong aria-hidden="true">13.23.</strong> ❌最小コスト</a></li></ol></li><li class="chapter-item expanded "><a href="uncategorized/index.html"><strong aria-hidden="true">14.</strong> 未分類</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="uncategorized/imos.html"><strong aria-hidden="true">14.1.</strong> imos法</a></li><li class="chapter-item expanded "><a href="uncategorized/imos2d.html"><strong aria-hidden="true">14.2.</strong> 2次元imos法</a></li><li class="chapter-item expanded "><a href="uncategorized/imoss.html"><strong aria-hidden="true">14.3.</strong> 座標圧縮imos法</a></li><li class="chapter-item expanded "><a href="uncategorized/imos2ds.html"><strong aria-hidden="true">14.4.</strong> 座標圧縮2次元imos法</a></li><li class="chapter-item expanded "><a href="uncategorized/rui.html"><strong aria-hidden="true">14.5.</strong> 累積和</a></li><li class="chapter-item expanded "><a href="uncategorized/rui2d.html"><strong aria-hidden="true">14.6.</strong> 2次元累積和</a></li><li class="chapter-item expanded "><a href="uncategorized/bs.html"><strong aria-hidden="true">14.7.</strong> 要素を2分探索</a></li><li class="chapter-item expanded "><a href="uncategorized/wday.html"><strong aria-hidden="true">14.8.</strong> 日付計算</a></li><li class="chapter-item expanded "><a href="uncategorized/mex.html"><strong aria-hidden="true">14.9.</strong> Mex関数</a></li><li class="chapter-item expanded "><a href="uncategorized/mo.html"><strong aria-hidden="true">14.10.</strong> ❌Mo's algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="famous/index.html"><strong aria-hidden="true">15.</strong> 有名問題</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="famous/inv.html"><strong aria-hidden="true">15.1.</strong> 転倒数計算</a></li><li class="chapter-item expanded "><a href="famous/in-ex.html"><strong aria-hidden="true">15.2.</strong> 包除原理</a></li><li class="chapter-item expanded "><a href="famous/fibo.html"><strong aria-hidden="true">15.3.</strong> 線形漸化式</a></li><li class="chapter-item expanded "><a href="famous/hist.html"><strong aria-hidden="true">15.4.</strong> ❌ヒストグラムの最大長方形</a></li><li class="chapter-item expanded "><a href="famous/sliding.html"><strong aria-hidden="true">15.5.</strong> ❌スライド最小値</a></li><li class="chapter-item expanded "><a href="famous/12.html"><strong aria-hidden="true">15.6.</strong> ❌写像12相</a></li><li class="chapter-item expanded "><a href="famous/polya.html"><strong aria-hidden="true">15.7.</strong> ❌ポリアの数え上げ定理</a></li><li class="chapter-item expanded "><a href="famous/LIS.html"><strong aria-hidden="true">15.8.</strong> ❌LIS</a></li><li class="chapter-item expanded "><a href="famous/LCS.html"><strong aria-hidden="true">15.9.</strong> ❌LCS</a></li><li class="chapter-item expanded "><a href="famous/knap.html"><strong aria-hidden="true">15.10.</strong> ❌ナップザック問題</a></li><li class="chapter-item expanded "><a href="famous/tsp.html"><strong aria-hidden="true">15.11.</strong> ❌巡回セールスマン問題</a></li><li class="chapter-item expanded "><a href="famouse/burn.html"><strong aria-hidden="true">15.12.</strong> ❌燃やす埋める問題</a></li><li class="chapter-item expanded "><a href="famouse/mow.html"><strong aria-hidden="true">15.13.</strong> ❌牛ゲー</a></li><li class="chapter-item expanded "><a href="famouse/pal.html"><strong aria-hidden="true">15.14.</strong> ❌最長回文</a></li></ol></li><li class="chapter-item expanded "><a href="past/index.html"><strong aria-hidden="true">16.</strong> アルゴリズム検定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="past/01.html"><strong aria-hidden="true">16.1.</strong> ⚠️第1回アルゴリズム検定</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">shiba&#x27;s Library</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="このライブラリについて"><a class="header" href="#このライブラリについて">このライブラリについて</a></h1>
<h2 id="関連リンク"><a class="header" href="#関連リンク">関連リンク</a></h2>
<ul>
<li>CTF関連は<a href="https://shibaken28.github.io/CTF-writeups/about.html">こちら</a>にも書いています．</li>
</ul>
<h2 id="各事項"><a class="header" href="#各事項">各事項</a></h2>
<ul>
<li>動作は保証しません．
<ul>
<li>issueを出してくださると直すかもしれません．</li>
<li>❌がついている項目は未実装です．</li>
<li>⚠️がついている項目は未実装なところが一部あります．</li>
</ul>
</li>
<li>CTF関係のプログラムのみpython，他は全てC++です．</li>
<li>ドキュメントの充実さよりも項目を増やすことの方が優先度が高いので説明文は結構適当です．</li>
<li>全てのソースコードを私shibaken28が書いたわけではないです
<ul>
<li>自分が書いていないコードはCC0ライセンスで公開されているものを使用しています．</li>
<li>余談ですが，勉強のため，できるだけ自分で一度は実装するようにしています．</li>
</ul>
</li>
</ul>
<h2 id="メモ"><a class="header" href="#メモ">メモ</a></h2>
<p><code>git subtree push --prefix docs/book/ origin gh-pages</code></p>
<h1 id="よくあるテクニック"><a class="header" href="#よくあるテクニック">よくあるテクニック</a></h1>
<h2 id="メタ読み"><a class="header" href="#メタ読み">メタ読み</a></h2>
<ul>
<li>制約が$N=20$のときは，$2^N$通りのbit全探索</li>
<li>制約が$N=40$くらいのときは半分全列挙
<ul>
<li>これは半分全列挙感がすごい<a href="https://atcoder.jp/contests/abc271/tasks/abc271_f">ABC271 F - XOR on Grid Path</a></li>
</ul>
</li>
</ul>
<h2 id="線形変換"><a class="header" href="#線形変換">線形変換</a></h2>
<ul>
<li><a href="./famous/fibo.html">線形漸化式</a></li>
<li>行列を使って表すことができる</li>
<li>dpの遷移が線形変換で表せるときは高速化ができる</li>
<li><a href="./natural/bsgs.html">BasyStepGiantStep</a>が使えるパターン(<a href="https://atcoder.jp/contests/abc270/tasks/abc270_g">ABC270 G - Sequence in mod P</a>)</li>
<li>セグメントツリーに乗る<a href="https://atcoder.jp/contests/arc008/tasks/arc008_4">ARC008 D - タコヤキオイシクナール</a></li>
</ul>
<h2 id="cinとcoutを定義"><a class="header" href="#cinとcoutを定義"><code>cin</code>と<code>cout</code>を定義</a></h2>
<p><code>vector</code>とか<code>pair</code>，<code>set</code>を<code>cout</code>できるようにすると便利．</p>
<pre><code class="language-cpp">//vector
template&lt;class T&gt; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const vector&lt;T&gt; &amp;A){
    for(const T &amp;a:A){
        cout&lt;&lt;a&lt;&lt;&quot; &quot;;
    }
    return out;
}
//pair
template&lt;class T1,class T2&gt; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const pair&lt;T1,T2&gt; &amp;A){
    cout&lt;&lt;&quot;{&quot;&lt;&lt;A.first&lt;&lt;&quot;,&quot;&lt;&lt;A.second&lt;&lt;&quot;}&quot;;
    return out;
}
//map
template&lt;class T1,class T2&gt; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const map&lt;T1,T2&gt; &amp;M){
    for(const auto&amp;A:M){
        cout&lt;&lt;&quot;{&quot;&lt;&lt;A.first&lt;&lt;&quot;,&quot;&lt;&lt;A.second&lt;&lt;&quot;}&quot;;
    }
    return out;
}
//set
template&lt;class T1&gt; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const set&lt;T1&gt; &amp;M){
    cout&lt;&lt;&quot;{&quot;;
    for(const auto&amp;A:M){
        cout&lt;&lt;A&lt;&lt;&quot;, &quot;;
    }
    cout&lt;&lt;&quot;}&quot;&lt;&lt;endl;
    return out;
}
</code></pre>
<p>また，<code>cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl</code>は次の定義によって<code>print(a,b,c,d)</code>で書ける(厳密には余計な空白が入るので注意)．</p>
<pre><code class="language-cpp">void print() { cout &lt;&lt; endl; }
 
template &lt;typename Head, typename... Tail&gt;
void print(Head H, Tail... T) {
  cout &lt;&lt; H &lt;&lt; &quot; &quot;;
  print(T...);
}
</code></pre>
<h1 id="cの仕様や便利機能"><a class="header" href="#cの仕様や便利機能">C++の仕様や便利機能</a></h1>
<h2 id="参考になった資料"><a class="header" href="#参考になった資料">参考になった資料</a></h2>
<ul>
<li><a href="https://zenn.dev/tetsurom/books/restart-cpp11/viewer/range-for-loops">C++11実践復習(β)</a></li>
<li><a href="https://koturn.hatenablog.com/entry/2018/06/10/060000">ラムダ式で再帰をする</a></li>
</ul>
<h2 id="makefile"><a class="header" href="#makefile">Makefile</a></h2>
<p>オプションをつけないとC++17でコンパイル<strong>されない</strong>．構造体束縛とかが使えなくて泣く．
毎回オプションを付けるのは面倒なので，Makefileを作っておくと便利．</p>
<pre><code class="language-makefile">#Makefile
CC=g++
CFLAGS=-Wall -std=c++17
.SUFFIXES = .cpp
objs:=$(wildcard *.cpp)
targets:=$(objs:.cpp= )

.PHONY:all
all: $(targets)
.cpp:
	$(CC) $(CFLAGS) -o $@ $&lt;
</code></pre>
<h2 id="構造体束縛"><a class="header" href="#構造体束縛">構造体束縛</a></h2>
<p><a href="https://cpprefjp.github.io/lang/cpp17/structured_bindings.html">C++日本語リファレンス</a>よりコードを引用</p>
<pre><code class="language-cpp">std::pair&lt;int, std::string&gt; f()
{
  return {3, &quot;Hello&quot;};
}

// 関数f()の戻り値である整数と文字列の組を分解する。
// pairのfirstをid変数に代入し、secondをmessage変数に代入する。
// id変数の型はfirstの型(int)となり、message変数の型はsecondの型(string)となる。
auto [id, message] = f();
</code></pre>
<p>これにより，pair型などで受け取って中身をいちいち別の変数に取り出す手間がなくなる．</p>
<p><code>map</code>の値の取り出しでも重宝する．</p>
<pre><code class="language-cpp">map&lt;int,int&gt; mp;
for(auto [key,value]:mp){
    //key,valueを使う
    cout&lt;&lt;key&lt;&lt;&quot; &quot;&lt;&lt;value&lt;&lt;endl;
}
</code></pre>
<h2 id="ラムダ式"><a class="header" href="#ラムダ式">ラムダ式</a></h2>
<p>関数に関数を渡すときに便利．構文は次の通り．</p>
<pre><code class="language-cpp">[キャプチャする変数](引数){ 関数の本体 }
</code></pre>
<p>型名はよくわかんないので<code>auto</code>に任しておく．</p>
<pre><code class="language-cpp">auto pow = [](int a){return a*a;}; //引数aを受け取ってa*aを返す関数
cout&lt;&lt;pow(4)&lt;&lt;endl; //16
</code></pre>
<p>ラムダ式の中で外の変数を使いたい場合はキャプチャする．</p>
<pre><code class="language-cpp">int x=4;
auto mul = [x](int a){return x*a;};
cout&lt;&lt;mul(3)&lt;&lt;endl; //12
</code></pre>
<p><code>&amp;</code>を付けると参照キャプチャになる．他にもキャプチャの種類があるがここでは紹介しない．</p>
<pre><code class="language-cpp">int x=4;
auto mul = [&amp;x](int a){return x*a;};
cout&lt;&lt;mul(3)&lt;&lt;endl; //12
</code></pre>
<h1 id="よくあるバグ"><a class="header" href="#よくあるバグ">よくあるバグ</a></h1>
<h2 id="前提"><a class="header" href="#前提">前提</a></h2>
<ul>
<li>コンパイルするファイルが間違っている</li>
<li>実行するファイルが間違っている</li>
<li>実はコンパイルに失敗していて，最後にコンパイルが成功したファイルを実行している</li>
</ul>
<h2 id="コンパイルできない"><a class="header" href="#コンパイルできない">コンパイルできない</a></h2>
<ul>
<li>ヘッダがない
<ul>
<li>人のコードパクってきたときに<code>funcional</code>ヘッダがなかった</li>
</ul>
</li>
<li><code>using namespace</code>がない</li>
<li>変数名と<code>define</code>の重複</li>
<li><code>vector&lt;vector&lt;long&gt;&gt; A(N,vector&lt;int&gt;(0))</code>みたいに型が一致していない</li>
<li><code>&lt;Templete T&gt;</code>の書き忘れ</li>
</ul>
<h2 id="コーナーケース"><a class="header" href="#コーナーケース">コーナーケース</a></h2>
<ul>
<li><code>N=1,K=0</code>などの極端な値</li>
<li><code>A=B</code>のとき</li>
<li>同じクエリが複数回来るかもしれない</li>
<li>自己ループ，同じ辺</li>
<li>0の0乗,0の階乗の定義</li>
</ul>
<h2 id="実行が終わらない"><a class="header" href="#実行が終わらない">実行が終わらない</a></h2>
<ul>
<li>入力を受け取りすぎている
<ul>
<li>クエリの数<code>Q</code>と要素数<code>N</code>が混同してしまう</li>
</ul>
</li>
<li>n重for文でインクリメントする変数を間違える</li>
<li>n重for文で変数名が重複</li>
<li>計算量が多い
<ul>
<li>setに要素を大量に入れている可能性</li>
</ul>
</li>
</ul>
<h2 id="セグフォ"><a class="header" href="#セグフォ">セグフォ</a></h2>
<ul>
<li>cinを忘れている</li>
<li>二項係数ライブラリとかの前計算した配列の範囲外参照</li>
<li>文字列の操作中に空文字が登場する</li>
<li>0,1-indexedの混同
<ul>
<li>セグ木とかに多い</li>
</ul>
</li>
</ul>
<h2 id="その他ハマり"><a class="header" href="#その他ハマり">その他ハマり</a></h2>
<h3 id="modを正しく取れていない"><a class="header" href="#modを正しく取れていない">modを正しく取れていない</a></h3>
<ul>
<li>modを取ってない</li>
<li>mod(法)の値が間違っている(998244353,1e9+7)</li>
<li>modの取り方を間違っている
<ul>
<li>法が素数でない，逆元が存在しない</li>
<li>mod 3とかでの二項係数はルーカスの定理を使う</li>
</ul>
</li>
<li>modを取りながら累積和したときに負の数がでる
<ul>
<li><code>(A[r]-A[l-1]+mod)%mod</code>みたいな配慮</li>
<li><code>modint</code>構造体を使おう</li>
</ul>
</li>
<li>最後にマイナス1などをしている(0のときに-1が出力されてしまう)</li>
</ul>
<h3 id="セグ木"><a class="header" href="#セグ木">セグ木</a></h3>
<ul>
<li>実はモノイドではなかった</li>
<li>単位元が間違っている
<ul>
<li>更新クエリの単位元を$0$にすると壊れる場合がある</li>
</ul>
</li>
<li>ビルドができていない</li>
</ul>
<h3 id="二分探索"><a class="header" href="#二分探索">二分探索</a></h3>
<ul>
<li>初期値で候補から外れている値が実は答え
<ul>
<li>答えの上限値が<code>10^9</code>なのに二分探索の上限の初期値を<code>10^9</code>にしている</li>
</ul>
</li>
</ul>
<h3 id="未分類"><a class="header" href="#未分類">未分類</a></h3>
<ul>
<li>改行(flush)しないと標準出力にでてこない</li>
<li><code>cin&gt;&gt;a,b;</code>みたいなことをしている
<ul>
<li>エラーが出ないことがあるのでハマりやすい</li>
</ul>
</li>
<li>switch文でbreak忘れ</li>
<li><code>make clean</code>を試す</li>
<li>型のパース，intをlongの計算にそのまま突っ込むのは良くない</li>
<li>調和級数の計算量勘違い</li>
<li>コンストラクタの名前を間違えている</li>
<li>閉区間，半開区間などの違い
<ul>
<li>累積和で区間和を出す場合に注意</li>
</ul>
</li>
<li><code>set</code>や<code>map</code>で<code>std::lower_bound</code>などは使えない
<ul>
<li>メソッドとして用意されている</li>
</ul>
</li>
<li>01ナップザックで昇順にdpを回してしまった
<ul>
<li>それは個数制限なし</li>
</ul>
</li>
<li>bool型をint型だと思って
<ul>
<li>bool値に2以上を入れてもサイレントに1になる</li>
</ul>
</li>
<li>ソート後の配列をソート前の状態として扱ってしまった</li>
<li>格子点とグリッドマス目の関係
<ul>
<li>角の座標の扱い</li>
</ul>
</li>
<li>不等式における累乗の注意
<ul>
<li>偶数乗した場合負の数が正になる</li>
</ul>
</li>
<li>ビットシフト演算子の計算順序
<ul>
<li>四則演算のほうが早い(<code>1&lt;&lt;2+2</code>は<code>1&lt;&lt;4</code>で<code>16</code>になる)</li>
</ul>
</li>
<li><code>long</code>型リテラルにしわすれてオーバーフロー
<ul>
<li><code>1&lt;&lt;40</code>はオーバーフローする．<code>1L&lt;&lt;40</code>が正しい．</li>
</ul>
</li>
</ul>
<h1 id="データ構造"><a class="header" href="#データ構造">データ構造</a></h1>
<h1 id="cが用意しているデータ構造"><a class="header" href="#cが用意しているデータ構造">C++が用意しているデータ構造</a></h1>
<ul>
<li><a href="https://zenn.dev/reputeless/books/standard-cpp-for-competitive-programming">競プロのための標準C++</a></li>
</ul>
<h2 id="vector"><a class="header" href="#vector"><code>vector</code></a></h2>
<ul>
<li>配列．</li>
<li><code># include &lt; vector &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化"><a class="header" href="#初期化">初期化</a></h3>
<pre><code class="language-cpp">vector&lt;int&gt; A(10,0); // 10個の要素を持つint型の配列．初期値は0．
vector&lt;int&gt; B = {3,1,4,1,5}; //要素を指定して初期化．
vector&lt;int&gt; C;// 空の配列．
</code></pre>
<h3 id="要素の取得"><a class="header" href="#要素の取得">要素の取得</a></h3>
<p>ランダムアクセスが$O(1)$で可能．</p>
<pre><code class="language-cpp">vector&lt;int&gt; A = {3,1,4,1,5};
cout &lt;&lt; A[0] &lt;&lt; endl; // 3
cout &lt;&lt; A[1] &lt;&lt; endl; // 1
cout &lt;&lt; A[2] &lt;&lt; endl; // 4
cout &lt;&lt; A[3] &lt;&lt; endl; // 1
cout &lt;&lt; A[4] &lt;&lt; endl; // 5
cout &lt;&lt; A.size() &lt;&lt; endl; // 要素数を返す．
</code></pre>
<h3 id="要素の追加と削除"><a class="header" href="#要素の追加と削除">要素の追加と削除</a></h3>
<pre><code class="language-cpp">vector&lt;int&gt; C;// 空の配列．
C.push_back(2); // Cの末尾に2を追加．
C.pop_back(); // Cの末尾の要素を削除．
</code></pre>
<h3 id="ソート"><a class="header" href="#ソート">ソート</a></h3>
<p>$O(N\log N)$かかる．</p>
<pre><code class="language-cpp">vector&lt;int&gt; B = {3,1,4,1,5};
sort(B.begin(),B.end()); // Bを昇順に並び替え．
sort(B.begin(),B.end(),greater&lt;int&gt;()); // Bを降順に並び替え．
</code></pre>
<h2 id="set"><a class="header" href="#set"><code>set</code></a></h2>
<ul>
<li>重複なしの集合．</li>
<li><code># include &lt; set &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-1"><a class="header" href="#初期化-1">初期化</a></h3>
<pre><code class="language-cpp">set&lt;int&gt; A = {3,1,4,1,5}; //要素を指定して初期化．
set&lt;int&gt; B;// 空の集合．
</code></pre>
<h3 id="要素の取得-1"><a class="header" href="#要素の取得-1">要素の取得</a></h3>
<ul>
<li>ランダムアクセスはできない．</li>
<li>range based for loopが使える．</li>
<li>要素が含まれているかは$O(\log N)$で<code>count</code>メンバ関数で判定できる($0$ならば含まれていない，$1$ならば含まれている)．</li>
<li>イテレータの使用して次に大きい要素や次に小さい要素を取得することもできる(<a href="structure/./../uncategorized/bs.html">詳細</a>)．</li>
</ul>
<pre><code class="language-cpp">set&lt;int&gt; A = {3,1,4,1,5};
cout &lt;&lt; A.size() &lt;&lt; endl; //4．要素数を返す．
for(auto x:A){
    cout &lt;&lt; x &lt;&lt; endl; // 1,3,4,5の順に出力される．
    //勝手に昇順になっている．要素は重複しない．
}
cout &lt;&lt; A.count(1) &lt;&lt; endl; // 1がAに含まれているか．
</code></pre>
<h3 id="要素の追加と削除-1"><a class="header" href="#要素の追加と削除-1">要素の追加と削除</a></h3>
<pre><code class="language-cpp">set&lt;int&gt; B;// 空の集合．
B.insert(2); // Bに2を追加．
B.erase(2); // Bから2を削除．
</code></pre>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<ul>
<li>キーと値のペアを格納する．</li>
<li><code># include &lt; map &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-2"><a class="header" href="#初期化-2">初期化</a></h3>
<pre><code class="language-cpp">map&lt;int,int&gt; A = {{1,2},{3,4},{5,6}}; //要素を指定して初期化．
map&lt;int,int&gt; B;// 空のmap．
</code></pre>
<h3 id="要素の取得-2"><a class="header" href="#要素の取得-2">要素の取得</a></h3>
<ul>
<li>ランダムアクセスはできない．</li>
<li>range based for loopが使える(キーと値が<code>pair</code>型でもらえる)．</li>
<li>イテレータの使用して次に大きい要素や次に小さい要素を取得することもできる(<a href="structure/./../uncategorized/bs.html">詳細</a>)．</li>
</ul>
<pre><code class="language-cpp">map&lt;int,int&gt; A = {{1,2},{3,4},{5,6}};
cout &lt;&lt; A.size() &lt;&lt; endl; //3．要素数を返す．
cout &lt;&lt; A[1] &lt;&lt; endl; // 2
cout &lt;&lt; A[3] &lt;&lt; endl; // 4
cout &lt;&lt; A[5] &lt;&lt; endl; // 6
for(auto x:A){
    cout &lt;&lt; x.first &lt;&lt; &quot; &quot; &lt;&lt; x.second &lt;&lt; endl; // 1 2,3 4,5 6の順に出力される．
    //勝手にキーの昇順になっている．
}
</code></pre>
<h2 id="queue"><a class="header" href="#queue"><code>queue</code></a></h2>
<ul>
<li>LIFO(First In First Out)のデータ構造．</li>
<li><code># include &lt; queue &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-3"><a class="header" href="#初期化-3">初期化</a></h3>
<pre><code class="language-cpp">queue&lt;int&gt; A;// 空のqueue．
</code></pre>
<h3 id="要素の操作"><a class="header" href="#要素の操作">要素の操作</a></h3>
<pre><code class="language-cpp">queue&lt;int&gt; A;
A.push(1); // Aの末尾に1を追加．
A.push(2); // Aの末尾に2を追加．
A.push(3); // Aの末尾に3を追加．
cout &lt;&lt; A[0] &lt;&lt; endl; // 1
cout &lt;&lt; A.front() &lt;&lt; endl; // 1
A.pop(); // Aの先頭の要素を削除．
cout &lt;&lt; A.front() &lt;&lt; endl; // 2
A.pop(); // Aの先頭の要素を削除．
cout &lt;&lt; A.front() &lt;&lt; endl; // 3
A.pop(); // Aの先頭の要素を削除．
</code></pre>
<h2 id="stack"><a class="header" href="#stack"><code>stack</code></a></h2>
<p>FIFO(First In Last Out)のデータ構造．</p>
<h3 id="初期化-4"><a class="header" href="#初期化-4">初期化</a></h3>
<pre><code class="language-cpp">stack&lt;int&gt; A;// 空のstack．
</code></pre>
<h3 id="要素の操作-1"><a class="header" href="#要素の操作-1">要素の操作</a></h3>
<pre><code class="language-cpp">stack&lt;int&gt; A;
A.push(1); // Aの末尾に1を追加．
A.push(2); // Aの末尾に2を追加．
A.push(3); // Aの末尾に3を追加．
cout &lt;&lt; A.top() &lt;&lt; endl; // 3
A.pop(); // Aの末尾の要素を削除．
cout &lt;&lt; A.top() &lt;&lt; endl; // 2
A.pop(); // Aの末尾の要素を削除．
cout &lt;&lt; A.top() &lt;&lt; endl; // 1
A.pop(); // Aの末尾の要素を削除．
</code></pre>
<h2 id="deque"><a class="header" href="#deque"><code>deque</code></a></h2>
<ul>
<li><code>queue</code>と<code>stack</code>のキメラ．ランダムアクセスも可能である．</li>
<li><code># include &lt; deque &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-5"><a class="header" href="#初期化-5">初期化</a></h3>
<pre><code class="language-cpp">deque&lt;int&gt; A;// 空のdeque．
</code></pre>
<h3 id="要素の操作-2"><a class="header" href="#要素の操作-2">要素の操作</a></h3>
<pre><code class="language-cpp">deque&lt;int&gt; A;
A.push_back(1); // Aの末尾に1を追加．
A.push_back(2); // Aの末尾に2を追加．
A.push_back(3); // Aの末尾に3を追加．
A.push_front(4); // Aの先頭に4を追加．
A.push_front(5); // Aの先頭に5を追加．
A.push_front(6); // Aの先頭に6を追加．
cout &lt;&lt; A[0] &lt;&lt; endl; // 6
cout &lt;&lt; A[1] &lt;&lt; endl; // 5
cout &lt;&lt; A[2] &lt;&lt; endl; // 4
cout &lt;&lt; A[3] &lt;&lt; endl; // 1
cout &lt;&lt; A[4] &lt;&lt; endl; // 2
cout &lt;&lt; A[5] &lt;&lt; endl; // 3
A.pop_back(); // Aの末尾の要素を削除．
A.pop_front(); // Aの先頭の要素を削除．
cout &lt;&lt; A[0] &lt;&lt; endl; // 5
cout &lt;&lt; A[1] &lt;&lt; endl; // 4
cout &lt;&lt; A[2] &lt;&lt; endl; // 1
cout &lt;&lt; A[3] &lt;&lt; endl; // 2
</code></pre>
<h2 id="priority_queue"><a class="header" href="#priority_queue"><code>priority_queue</code></a></h2>
<ul>
<li>優先度付きキュー．</li>
<li><code># include &lt; queue &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-6"><a class="header" href="#初期化-6">初期化</a></h3>
<pre><code class="language-cpp">priority_queue&lt;int&gt; A;// 空のpriority_queue．
</code></pre>
<h3 id="要素の操作-3"><a class="header" href="#要素の操作-3">要素の操作</a></h3>
<p>大きい方から出てくる．</p>
<pre><code class="language-cpp">priority_queue&lt;int&gt; A;
A.push(2); // Aの末尾に2を追加．
A.push(3); // Aの末尾に3を追加．
A.push(1); // Aの末尾に1を追加．
cout &lt;&lt; A.top() &lt;&lt; endl; // 3
A.pop(); // Aの末尾の要素を削除．
cout &lt;&lt; A.top() &lt;&lt; endl; // 2
A.pop(); // Aの末尾の要素を削除．
cout &lt;&lt; A.top() &lt;&lt; endl; // 1
A.pop(); // Aの末尾の要素を削除．
</code></pre>
<h2 id="list"><a class="header" href="#list"><code>list</code></a></h2>
<ul>
<li>双方向連結リスト．</li>
<li><code># include &lt; list &gt;</code>ヘッダをインクルードすることで使用できる．</li>
</ul>
<h3 id="初期化-7"><a class="header" href="#初期化-7">初期化</a></h3>
<pre><code class="language-cpp">list&lt;int&gt; A;// 空のlist．
</code></pre>
<h3 id="要素の操作-4"><a class="header" href="#要素の操作-4">要素の操作</a></h3>
<pre><code class="language-cpp">list&lt;int&gt; ls;
ls.push_back(1);
ls.push_back(2);
ls.push_front(3);
ls.push_front(4);
for_each(ls.begin(),ls.end(),[](int a){
    cout&lt;&lt;a&lt;&lt;&quot; &quot;; // 4 3 1 2
});
cout&lt;&lt;endl;
auto it = ls.begin();
it++;
ls.insert(it,5);
for_each(ls.begin(),ls.end(),[](int a){
    cout&lt;&lt;a&lt;&lt;&quot; &quot;; // 4 5 3 1 2
});
cout&lt;&lt;endl;
</code></pre>
<h1 id="unionfind"><a class="header" href="#unionfind">UnionFind</a></h1>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p>UnionFindは、グラフの連結成分を管理するデータ構造．
次の操作がそれぞれ高速(ほぼ定数時間)に行える．</p>
<ul>
<li><code>root(x)</code> : <code>x</code>の根を返す．</li>
<li><code>unite(u,v)</code> : <code>u</code>,<code>v</code>をマージする</li>
<li><code>same(u,v)</code> : <code>u</code>,<code>v</code>が同じ連結成分に属するかを判定する．</li>
<li><code>getGroup(x)</code> : 現在の連結成分のリストを返す．</li>
<li><code>getWeight(x)</code> : <code>x</code>が属する連結成分の重みを返す．</li>
<li><code>changeWeight(x)</code> : 頂点<code>x</code>の重みを変更する．</li>
</ul>
<h2 id="ソースコード"><a class="header" href="#ソースコード">ソースコード</a></h2>
<pre><code class="language-cpp">
struct UnionFind{
    public:
    vector&lt;int&gt; par;//親
    vector&lt;long&gt; weight;//重み
    vector&lt;long&gt; weightAlone;//単体の重み
    UnionFind(int n):par(n),weight(n),weightAlone(n){
        for(int i=0;i&lt;n;i++){
            par[i]=i; //親は自分自身にしておく
            weight[i] = weightAlone[i] = 1;
        }
    }
    //途中で実行すると壊れます
    void setWeight(int i,long w){
        weight[i] = weightAlone[i] = w;
    }
    //途中で実行しても大丈夫
    void changeWeight(int i,long w){
        long pre = weightAlone[i];
        weightAlone[i] = w;
        weight[root(i)] += w-pre;
    }
    int root(int x){
        if(par[x]==x){
            return x;
        }else{
            int r = root(par[x]);
            par[x]=r;
            return r;
        }
    }
    void unite(int x,int y){
        int rx=root(x);
        int ry=root(y);
        if(rx==ry){
            return;
        }
        par[rx]=ry;
        weight[ry] += weight[rx];
    }
    bool same(int x,int y){
        int rx=root(x);
        int ry=root(y);
        return rx==ry;
    }
    long getWeight(int x){
        return weight[root(x)];
    }
    vector&lt;vector&lt;int&gt;&gt; getGroups(){
        vector&lt;vector&lt;int&gt;&gt; res;
        map&lt;int,vector&lt;int&gt;&gt; mp;
        for(int i=0;i&lt;(int)par.size();i++){
            mp[root(i)].push_back(i);
        }
        for(auto&amp;[k,v]:mp){
            (void)k; //使いません
            res.push_back(v);
        }
        return res;
    }
};

</code></pre>
<p>重みは途中で変更できる．</p>
<pre><code class="language-cpp">int main(void){
    UnionFind uf(3);
    //初期の全ての頂点の重みは1
    uf.unite(1,2);
    cout&lt;&lt;uf.getWeight(1)&lt;&lt;endl; // 2(=1+1)
    uf.changeWeight(1,10);
    cout&lt;&lt;uf.getWeight(1)&lt;&lt;endl; // 11(=10+1)
    uf.unite(0,1);
    cout&lt;&lt;uf.getWeight(1)&lt;&lt;endl; // 12(=10+1+1)
}
</code></pre>
<h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<h2 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h2>
<p>さっそく抽象化すると(僕が)よくわからんので、例を挙げていく．</p>
<h2 id="range-minimum-query"><a class="header" href="#range-minimum-query">Range Minimum Query</a></h2>
<p>長さ$N$の数列($A_0,A_1,A_2,\cdots,A_{N-1}$)について，次のクエリを$O(\log N)$で行う</p>
<ul>
<li>$a_i$を$x$に<strong>更新</strong>する</li>
<li>区間の<strong>最小値</strong>を求める</li>
</ul>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/dsl/all/dsl_2_a">verify用問題</a></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct RMQ{
    int n;
    vector&lt;T&gt;dat;
    const T INF;
    RMQ(int n_,T INF_):INF(INF_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,INF);
    }
    void update(int k,T a){
        k+=n-1;// i番目は、配列上では n-1+i 番目に格納されている
        dat[k]=a;// 葉の更新
        while(k&gt;0){
            k=(k-1)/2; //親のインデックス
            // 子の内小さい方を選ぶ
            dat[k]=min(dat[k*2+1],dat[k*2+2]);
        }
    }
    // [a,b)の最小値を求める，頂点kは[l,r)に対応している
    T query(int a,int b,int k,int l,int r){
        if(r&lt;=a||b&lt;=l)return INF;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return min(vl,vr);
        }
    }
    //[a,b)の最小値を求める
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
};
</code></pre>
<h2 id="range-sum-query"><a class="header" href="#range-sum-query">Range Sum Query</a></h2>
<ul>
<li>$A_i$に$x$を<strong>加算</strong>する．</li>
<li>区間の<strong>総和</strong>を求める</li>
</ul>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_B">verify用問題</a></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct RSQ{
    int n;
    vector&lt;T&gt;dat;
    const T ZERO;
    RSQ(int n_,T ZERO_):ZERO(ZERO_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ZERO);
    }
    void update(int k,T a){
        k+=n-1;// i番目は、配列上では n-1+i 番目に格納されている
        dat[k]+=a;// 葉の更新
        while(k&gt;0){
            k=(k-1)/2; //親のインデックス
            // 子の和を計算
            dat[k]=dat[k*2+1]+dat[k*2+2];
        }
    }
    
    T query(int a,int b,int k,int l,int r){
        if(r&lt;=a||b&lt;=l)return ZERO;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }
    }
    //[a,b)の総和を求める
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
};

</code></pre>
<h2 id="抽象化"><a class="header" href="#抽象化">抽象化</a></h2>
<p>RMQとRSQを比較すると，<code>min</code>と<code>+</code>，<code>INF</code>と<code>ZERO</code>が違うだけで，ほとんど同じ．
これらを抽象化する．
<code>min</code>と<code>+</code>に当たるものを<code>FX</code>と定義し，<code>INF</code>と<code>ZERO</code>に当たるものを<code>ex</code>と定義する．</p>
<p>また，新たに</p>
<ul>
<li>葉の値を取得する関数<code>get</code></li>
<li>更新をせずに値を入れる関数<code>set</code></li>
<li><code>set</code>した後に実行したい構築処理<code>build</code></li>
</ul>
<p>を追加した．</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct SegTree{
    using FX = function&lt;T(T,T)&gt;; // TとTの演算結果Tを返す
    FX fx;
    int n;
    vector&lt;T&gt;dat;
    const T ex;//単位元(こいつとxを演算をしてもxになる)
    SegTree(int n_,T ex_,FX fx_):ex(ex_),fx(fx_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ex);
    }
    void set(int k,T a){
        k+=n-1;
        dat[k]=a;
    }
    void build(){
        for(int k=n-2;k&gt;=0;k--){
            dat[k]=fx(dat[k*2+1],dat[k*2+2]);
        }
    }
    void update(int k,T a){
        k+=n-1;// i番目は、配列上では n-1+i 番目に格納されている
        dat[k] = a;// 葉の更新
        while(k&gt;0){
            k=(k-1)/2; //親のインデックス
            // 子の和を計算
            dat[k]=fx(dat[k*2+1],dat[k*2+2]);
        }
    }
    
    T query(int a,int b,int k,int l,int r){
        if(r&lt;=a||b&lt;=l)return ex;//範囲外なので単位元を返す
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return fx(vl,vr);
        }
    }
    //[a,b)のfx(A_a,A_a+1,...,A_b-1)を返す
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
    T get(int k){
        return dat[k+n-1];
    }

};
</code></pre>
<p>RMQにしたいときは，次のように単位元と関数を与える．</p>
<pre><code class="language-cpp">SegTree&lt;int&gt;st(n,2147483647,[](int a,int b){return min(a,b);});
</code></pre>
<p>先程のRSQにしたいときは，次のように単位元と関数を与える．
ただし，$x$を加算するという操作が先程の設計だとできないので．$A_i+x$に更新すると言い換える必要がある．あるいはコードを変更する．</p>
<pre><code class="language-cpp">SegTree&lt;int&gt;st(n,0,[](int a,int b){return a+b;});
</code></pre>
<p><strong>モノイド</strong>であればセグ木に乗せることができると知られている．</p>
<p>モノイドとは次の性質を満たす集合$M$と演算$\circ$($M\times M\longmapsto M$)の<strong>組</strong>である．</p>
<ul>
<li>$M$の任意の元$a,b,c$に対して，$(a\circ b)\circ c=a\circ (b\circ c)$を満たす．</li>
<li>$M$の任意の元$a$に対して，$a\circ e=e\circ a=a$を満たす$M$の単位元$e$が存在する．</li>
</ul>
<p>RMQで考えると，$M=\mathbb{N}$，$a\circ b=\textrm{min}(a,b)$，$e=\infty$であり，次が成り立つ．</p>
<ul>
<li>$\textrm{min}(\textrm{min}(a,c),b)=\textrm{min}(a,\textrm{min}(b,c))$</li>
<li>$\textrm{min}(a,\infty)=\textrm{min}(\infty,a)=a$</li>
</ul>
<p>モノイドであり，セグ木に乗せられることが確認できる．</p>
<h2 id="range-gcd-query"><a class="header" href="#range-gcd-query">Range GCD Query</a></h2>
<p>亜種として，区間の最大公約数を求める<a href="https://atcoder.jp/contests/abc125/tasks/abc125_c">問題</a>について考える．</p>
<p>この問題は，好きな$A_i$を一つ選んでそれを削除したときの，$A_1,A_2,...,A_{N-1}$の最大公約数の最大値を求める問題だと言い換えることができる．</p>
<ul>
<li>演算を$\textrm{GCD}$とする．</li>
<li>$\textrm{GCD}(x,0)=x$と定義すると単位元は$0$である．</li>
</ul>
<p>$\textrm{GCD}$は計算順序は関係なく，モノイドの条件をみたすため，セグ木にのせられることがわかる．</p>
<pre><code class="language-cpp">int GCD(int a,int b){
    if(a&lt;b)return GCD(b,a);
    if(b==0)return a;
    return GCD(b,a%b);
}

int main(void){
    int n;cin&gt;&gt;n;
    SegTree&lt;int&gt;st(n,0,[](int a,int b){return GCD(a,b);});
    for(int i=0;i&lt;n;i++){
        int a;
        cin&gt;&gt;a;
        st.set(i,a);
    }
    st.build();
    int ans = 0;
    for(int i=0;i&lt;n;i++){
        int l = st.query(0,i);
        int r = st.query(i+1,n);
        chmax(ans,GCD(l,r));
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</code></pre>
<p><a href="https://atcoder.jp/contests/abc125/submissions/35400383">提出結果</a></p>
<p>なお，この問題は左からと右からの累積GCDを使って解くことができるのでセグ木はオーバーキル解法である(しかもこっちのほうが遅い)が，新たに書くコードの少なくバグりづらいので殴れると何かと嬉しい．</p>
<h2 id="タコヤキオイシクナール"><a class="header" href="#タコヤキオイシクナール">タコヤキオイシクナール</a></h2>
<p><a href="https://atcoder.jp/contests/arc008/tasks/arc008_4">問題リンク</a>
試験管橙diffだが，今出題されれば水～青レベルだと思う(本当？)．</p>
<p>線形変換を行っていることに注目し，行列を考える．
美味しさ$x$のたこ焼きを$(a,b)$の機械に通すことを行列で表すと次のようになる．
$$
\begin{pmatrix}
x &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
a &amp; 0 \\
b &amp; 1 \\
\end{pmatrix}
=
\begin{pmatrix}
ax+b &amp; 1\\
\end{pmatrix}
$$
さらに，$(c,d)$の機械に通したものは次のように表現できる．
$$
\begin{pmatrix}
x &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
a &amp; 0 \\
b &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
c &amp; 0 \\
d &amp; 1 \\
\end{pmatrix}
=
\begin{pmatrix}
? &amp; 1\\
\end{pmatrix}
$$
また，</p>
<ul>
<li>$\mathbb{R}^{2\times 2}$の任意の元$A,B,C$で$(AB)C=A(BC)$</li>
<li>$\mathbb{R}^{2\times 2}$の任意の元$A$で，単位行列$I$を用意すると$AI=IA=A$</li>
</ul>
<p>であり，2次の正方行列の集合$\mathbb{R}^{2\times 2}$に対して，演算を行列の積とすると，モノイドであることがわかる．よって，セグ木に乗る．
なお，解くためには座標圧縮する必要がある．
<a href="https://atcoder.jp/contests/arc008/submissions/35401150">提出リンク</a></p>
<p>行列+セグ木+座圧のライブラリてんこ盛り問題．</p>
<h2 id="セグ木上の二分探索"><a class="header" href="#セグ木上の二分探索">セグ木上の二分探索</a></h2>
<p>未実装</p>
<h1 id="lazy-segment-tree"><a class="header" href="#lazy-segment-tree">Lazy Segment Tree</a></h1>
<h2 id="はじめに-1"><a class="header" href="#はじめに-1">はじめに</a></h2>
<p>遅延評価セグメント木は，抽象化してるやつを持っておいて，コンテストで出題されたらペタってやろうと企んでいる人がいる．しかし，意外と罠が多く，バグ取りに時間がかかってしまうことが多い．これは体験談．やはり，具体例を実際に実装して，その中で注意点を理解しておくのが良いと思う．</p>
<h2 id="range-minimum-query-and-range-update-query"><a class="header" href="#range-minimum-query-and-range-update-query">Range Minimum Query and Range Update Query</a></h2>
<p>長さ$N$の数列($A_0,A_1,A_2,\cdots,A_{N-1}$)について，次のクエリを$O(\log N)$で行う．</p>
<ul>
<li>区間の値を$x$に<strong>更新</strong></li>
<li>区間の最小値を取得</li>
</ul>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_F">verify用問題</a></p>
<p>なお，AOJにあるRangeUpdateQueryという問題は幅1のクエリだと考えれば解ける．</p>
<pre><code class="language-cpp">/*lazy segment tree*/
template&lt;class T&gt; class RMUQ{
    public:
        int n;
        vector&lt;T&gt;dat,lazy;
        const int INF;
    RMUQ(int n_,T INF_):INF(INF_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,INF);
        lazy.assign(2*n-1,INF);
    }
    void update(int a,int b,T x,int k,int l,int r){
        eval(k);
        if(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k]=x;
            eval(k);
        }else if(a &lt; r &amp;&amp; l &lt; b){
            update(a,b,x,k*2+1,l,(l+r)/2);
            update(a,b,x,k*2+2,(l+r)/2,r);
            dat[k]=min(dat[k*2+1],dat[k*2+2]);
        }
    }
    void update(int k,T a){
        update(k,k+1,a,0,0,n);
    }
    void update(int a,int b,T x){
        update(a,b,x,0,0,n);
    }
    void eval(int k){
        if(lazy[k]==INF)return;
        if(k&lt;n-1){
            lazy[k*2+1]=lazy[k];
            lazy[k*2+2]=lazy[k];
        }
        dat[k]=lazy[k];
        lazy[k]=INF;
    }
    // [a,b)の最小値を求める，頂点kは[l,r)に対応している
    T query(int a,int b,int k,int l,int r){
        eval(k);
        if(r&lt;=a||b&lt;=l)return INF;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return min(vl,vr);
        }
    }
    //[a,b)の最小値を求める
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
    T get(int k){
        return query(k,k+1);
    }
};
</code></pre>
<h2 id="range-add-query-and-range-sum-query"><a class="header" href="#range-add-query-and-range-sum-query">Range Add Query and Range Sum Query</a></h2>
<ul>
<li>区間の値に$x$を<strong>加算</strong></li>
<li>区間の和を取得</li>
</ul>
<p>実装で注意しなければならないのが区間に$x$を加算するときは，$x\times (区間の幅)$を<code>dat</code>に加算する必要があること．</p>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_G">verify用問題</a></p>
<pre><code class="language-cpp">
template&lt;class T&gt; class RSAQ{
    public:
        int n;
        vector&lt;T&gt;dat,lazy;
        const int ZERO;
    RSAQ(int n_,T ZERO_):ZERO(ZERO_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ZERO);
        lazy.assign(2*n-1,ZERO);
    }
    void update(int a,int b,T x,int k,int l,int r){
        eval(k,r-l);
        if(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k]+=x;
            eval(k,r-l);
        }else if(a &lt; r &amp;&amp; l &lt; b){
            update(a,b,x,k*2+1,l,(l+r)/2);
            update(a,b,x,k*2+2,(l+r)/2,r);
            dat[k]=dat[k*2+1]+dat[k*2+2];
        }
    }
    void update(int k,T a){
        update(k,k+1,a,0,0,n);
    }
    void update(int a,int b,T x){
        update(a,b,x,0,0,n);
    }
    void eval(int k,int len){
        if(lazy[k]==ZERO)return;
        if(k&lt;n-1){
            lazy[k*2+1]+=lazy[k];
            lazy[k*2+2]+=lazy[k];
        }
        dat[k]=dat[k] + lazy[k]*len;
        lazy[k]=ZERO;
    }
    // [a,b)の和を求める，頂点kは[l,r)に対応している
    T query(int a,int b,int k,int l,int r){
        eval(k,r-l);
        if(r&lt;=a||b&lt;=l)return ZERO;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }
    }
    //[a,b)の和
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
    T get(int k){
        return query(k,k+1);
    }
};
</code></pre>
<h2 id="range-minimum-query-and-range-add-query"><a class="header" href="#range-minimum-query-and-range-add-query">Range Minimum Query and Range Add Query</a></h2>
<ul>
<li>区間の値に$x$を<strong>加算</strong></li>
<li>区間の最小値を取得</li>
</ul>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_H">verify用問題</a></p>
<p>注意する点は，演算の種類が，加算と$\textrm{min}$の2種類ある点である．
この場合，どちらも単位元が異なり，加算は$0$で，$\textrm{min}$は$\infty$である．
また，<code>lazy</code>を<code>dat</code>に反映させるときは<code>dat = dat + lazy</code>となる(なぜなら，区間に$x$が加算されたらその区間の最小値も$x$増えるから)．</p>
<pre><code class="language-cpp">template&lt;class T&gt; class RMAQ{
    public:
        int n;
        vector&lt;T&gt;dat,lazy;
        const int ZERO,INF;
    RMAQ(int n_,T ZERO_,T INF_):ZERO(ZERO_),INF(INF_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ZERO);
        lazy.assign(2*n-1,ZERO);
    }
    void update(int a,int b,T x,int k,int l,int r){
        eval(k,r-l);
        if(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k]+=x;
            eval(k,r-l);
        }else if(a &lt; r &amp;&amp; l &lt; b){
            update(a,b,x,k*2+1,l,(l+r)/2);
            update(a,b,x,k*2+2,(l+r)/2,r);
            dat[k]=min(dat[k*2+1],dat[k*2+2]);
        }
    }
    void update(int k,T a){
        update(k,k+1,a,0,0,n);
    }
    void update(int a,int b,T x){
        update(a,b,x,0,0,n);
    }
    void eval(int k,int len){
        if(lazy[k]==ZERO)return;
        if(k&lt;n-1){
            lazy[k*2+1]+=lazy[k];
            lazy[k*2+2]+=lazy[k];
        }
        dat[k]=dat[k]+lazy[k];
        lazy[k]=ZERO;
    }
    // [a,b)の和を求める，頂点kは[l,r)に対応している
    T query(int a,int b,int k,int l,int r){
        eval(k,r-l);
        if(r&lt;=a||b&lt;=l)return INF;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return min(vl,vr);
        }
    }
    //[a,b)の和
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
    T get(int k){
        return query(k,k+1);
    }
};
</code></pre>
<h2 id="range-sum-query-and-range-update-query"><a class="header" href="#range-sum-query-and-range-update-query">Range Sum Query and Range Update Query</a></h2>
<ul>
<li>区間の値を$x$に<strong>更新</strong></li>
<li>区間の和を取得</li>
</ul>
<p><a href="https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_I">verify問題</a></p>
<p>注意するのは今まで<code>lazy</code>を$0$のときは<code>dat</code>に反映させないということをしていたが，今回は<code>lazy</code>が$0$のときも<code>dat</code>に反映させる必要があるということである．今回は$0$の代わりに<code>NONE</code>を使っている．この値はあり得ない値に設定してあるが，場合によってはこれも変える必要がでてくる．</p>
<p>抽象化の準備として，<code>NONE</code>を更新クエリの単位元と見ることとする．</p>
<pre><code class="language-cpp">template&lt;class T&gt; class RSUQ{
    public:
        int n;
        vector&lt;T&gt;dat,lazy;
        const int ZERO;
        const int NONE = 2147483647;
    RSUQ(int n_,T ZERO_):ZERO(ZERO_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ZERO);
        lazy.assign(2*n-1,NONE);
    }
    void update(int a,int b,T x,int k,int l,int r){
        eval(k,r-l);
        if(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k]=x;
            eval(k,r-l);
        }else if(a &lt; r &amp;&amp; l &lt; b){
            update(a,b,x,k*2+1,l,(l+r)/2);
            update(a,b,x,k*2+2,(l+r)/2,r);
            dat[k]=dat[k*2+1]+dat[k*2+2];
        }
    }
    void update(int k,T a){
        update(k,k+1,a,0,0,n);
    }
    void update(int a,int b,T x){
        update(a,b,x,0,0,n);
    }
    void eval(int k,int len){
        if(lazy[k]==NONE)return;
        if(k&lt;n-1){
            lazy[k*2+1]=lazy[k];
            lazy[k*2+2]=lazy[k];
        }
        dat[k]=lazy[k]*len;
        lazy[k]=NONE;
    }
    // [a,b)の和を求める，頂点kは[l,r)に対応している
    T query(int a,int b,int k,int l,int r){
        eval(k,r-l);
        if(r&lt;=a||b&lt;=l)return ZERO;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }
    }
    //[a,b)の和
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
    T get(int k){
        return query(k,k+1);
    }
};
</code></pre>
<h2 id="抽象化-1"><a class="header" href="#抽象化-1">抽象化</a></h2>
<p>今まで見てきた通り，抽象化するときは，ただのsegment treeと比べてユーザーが決める要素が多い．
遅延セグ木に乗せられる条件を列挙する(<a href="https://algo-logic.info/segment-tree/">参考</a>)．写像$p$を$p(m,n):=m*m*\cdots *m$($m$の$n$回の積)</p>
<ul>
<li>$X$と二項演算$\circ$がモノイド</li>
<li>$M$と二項演算$\bullet$がモノイド</li>
<li>$(x_1\circ x_2)* p(m,n) = (x_1*p(m,n/2))\circ(x_2*p(m,n/2)) (x_1,x_2\in X)$ 
<ul>
<li>子に伝播するときに半分ずつ伝播させるようなことができるか</li>
</ul>
</li>
<li>$(x* m_1)*m_2 = x*(m_1\times m_2)$
<ul>
<li>これが何なのか正直わからん(思考停止)</li>
</ul>
</li>
</ul>
<p>なお，$p(m,n)$は高速に計算できる必要がある．</p>
<p>モノイドについては<a href="structure/./segtree.html">SegTree</a>を参照．</p>
<pre><code class="language-cpp">template&lt;typename X,typename M&gt; struct LazySegmentTree{
    public:
        using FX = function&lt;X(X, X)&gt;;
        using FA = function&lt;X(X, M)&gt;;
        using FM = function&lt;M(M, M)&gt;;
        using FP = function&lt;M(M, int)&gt;;
        int n;
        FX fx;
        FA fa;
        FM fm;
        FP fp;
        const X ex;
        const M em;
        vector&lt;X&gt; dat;
        vector&lt;M&gt; lazy;
    LazySegmentTree(int n_,FX fx_,FA fa_,FM fm_,FP fp_,X ex_,M em_):n(n_),fx(fx_),fa(fa_),fm(fm_),fp(fp_),ex(ex_),em(em_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ex);
        lazy.assign(2*n-1,em);
    }
    void set(int k,X x){
        dat[k+n-1]=x;
    }
    void build(){
        for(int k=n-2;k&gt;=0;k--){
            dat[k]=fx(dat[2*k+1],dat[2*k+2]);
        }
    }
    void update(int a,int b,M x,int k,int l,int r){
        eval(k,r-l);
        if(a &lt;= l &amp;&amp; r &lt;= b){
            lazy[k]= fm(lazy[k],x);
            eval(k,r-l);
        }else if(a &lt; r &amp;&amp; l &lt; b){
            update(a,b,x,k*2+1,l,(l+r)/2);
            update(a,b,x,k*2+2,(l+r)/2,r);
            dat[k]=fx(dat[k*2+1],dat[k*2+2]);
        }
    }
    void update(int k,M a){
        update(k,k+1,a,0,0,n);
    }
    void update(int a,int b,M x){
        update(a,b,x,0,0,n);
    }
    void eval(int k,int len){
        if(lazy[k]==em)return;
        if(k&lt;n-1){
            lazy[k*2+1]=  fm(lazy[k*2+1],lazy[k]);
            lazy[k*2+2] = fm(lazy[k*2+2],lazy[k]);
        }
        dat[k]=fa(dat[k],fp(lazy[k],len));
        lazy[k]=em;
    }
    X query(int a,int b,int k,int l,int r){
        eval(k,r-l);
        if(r&lt;=a||b&lt;=l)return ex;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            X vl=query(a,b,k*2+1,l,(l+r)/2);
            X vr=query(a,b,k*2+2,(l+r)/2,r);
            return fx(vl,vr);
        }
    }
    X query(int a,int b){
        return query(a,b,0,0,n);
    }
    X get(int k){
        return query(k,k+1);
    }
};
</code></pre>
<p>各パラメータのイメージは以下の通り．</p>
<pre><code class="language-cpp">using X = long; // 持つデータの型
using M = long; // 遅延評価(クエリ)の型
auto fx = [](X a,X b){return min(a,b);}; // データの二項演算
auto fa = [](X a,M b){return b;}; // データにクエリを適用する
auto fm = [](M a,M b){return b;}; // 遅延評価の二項演算
auto fp = [](M a,int b){return a;}; // 遅延評価を幅bに適用した場合の遅延評価
X ex = (1L&lt;&lt;31)-1; //持つデータの演算の単位元
M em = 1e17; //遅延評価の演算の単位元
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
</code></pre>
<p>例を示す．</p>
<h4 id="range-minimum-query-and-range-update-query-1"><a class="header" href="#range-minimum-query-and-range-update-query-1">Range Minimum Query and Range Update Query</a></h4>
<pre><code class="language-cpp">using X = long;
using M = long;
auto fx = [](X a,X b){return min(a,b);};
auto fa = [](X a,M b){return b;};
auto fm = [](M a,M b){return b;};
auto fp = [](M a,int b){return a;};
X ex = (1L&lt;&lt;31)-1; //minの単位元
M em = 1e17; //更新クエリの単位元(ありえない数値)
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
</code></pre>
<h4 id="range-sum-query-and-range-add-query"><a class="header" href="#range-sum-query-and-range-add-query">Range Sum Query and Range Add Query</a></h4>
<pre><code class="language-cpp">using X = long;
using M = long;
auto fx = [](X a,X b){return a+b;};
auto fa = [](X a,M b){return a+b;};
auto fm = [](M a,M b){return a+b;};
auto fp = [](M a,int b){return a*b;};
X ex = 0; //sumの単位元
M em = 0; //加算クエリ+の単位元
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
</code></pre>
<h4 id="range-minimum-query-and-range-add-query-1"><a class="header" href="#range-minimum-query-and-range-add-query-1">Range Minimum Query and Range Add Query</a></h4>
<p>初期値に注意．</p>
<pre><code class="language-cpp">using X = long;
using M = long;
auto fx = [](X a,X b){return min(a,b);};
auto fa = [](X a,M b){return a+b;};
auto fm = [](M a,M b){return a+b;};
auto fp = [](M a,int b){return a;};
X ex = 1e17; //minの単位元
M em = 0; //加算クエリ+の単位元
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
for(int i=0;i&lt;N;i++){
    seg.set(i,0);//初期化
}
seg.build();
</code></pre>
<h4 id="range-sum-query-and-range-update-query-1"><a class="header" href="#range-sum-query-and-range-update-query-1">Range Sum Query and Range Update Query</a></h4>
<p>更新クエリの単位元はありえない数値(クエリに現れない数)にする．</p>
<pre><code class="language-cpp">using X = long;
using M = long;
auto fx = [](X a,X b){return a+b;};
auto fa = [](X a,M b){return b;};
auto fm = [](M a,M b){return b;};
auto fp = [](M a,int b){return a*(long)b;};
X ex = 0; //加算の単位元
M em = 1237615273123L; //更新クエリの単位元
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
for(int i=0;i&lt;N;i++){
    seg.set(i,0);//初期化
}
seg.build();
</code></pre>
<p>以下，応用例．</p>
<h2 id="range-xor-query"><a class="header" href="#range-xor-query">Range XOR Query</a></h2>
<ul>
<li><a href="https://atcoder.jp/contests/abc035/tasks/abc035_c">ABC035 C - オセロ</a></li>
<li><a href="https://atcoder.jp/contests/abc035/submissions/35406973">提出リンク</a></li>
</ul>
<p>黒と白を$0,1$とすると，オセロをひっくり返す操作は，1とのXORを取ることと等価である．
なお，ひっくり返す過程を出力する必要はないので，imos法とかで偶奇を見る方法でも解けるし，こちらのほうが早い．オーバーキルである．</p>
<pre><code class="language-cpp">using X = int;
using M = int;
auto fx = [](X a,X b){return a^b;};
auto fa = [](X a,M b){return a^b;};
auto fm = [](M a,M b){return a^b;};
auto fp = [](M a,int b){return a;};
X ex = 0; //xorの単位元
M em = 0; //xorの単位元
LazySegmentTree&lt;X,M&gt; seg(N,fx,fa,fm,fp,ex,em);
</code></pre>
<h2 id="range-add-linear-query"><a class="header" href="#range-add-linear-query">Range add linear Query</a></h2>
<p>区間に等差数列を加算する．</p>
<h1 id="binary-indexed-tree"><a class="header" href="#binary-indexed-tree">Binary Indexed Tree</a></h1>
<h2 id="概要-1"><a class="header" href="#概要-1">概要</a></h2>
<p>一点加算と区間和を $O(\log N)$ で行うデータ構造．
なお，<del>上位互換のsegment treeもこの機能を要しており，わざわざBITを使う必要はない</del>(実装が簡単，セグ木に対して定数倍早い，といった利点がある)．</p>
<h2 id="ソースコード-1"><a class="header" href="#ソースコード-1">ソースコード</a></h2>
<p>1-indexedなことに注意．</p>
<pre><code class="language-cpp">template&lt;class T&gt; std::istream &amp;operator&gt;&gt;(std::istream &amp;in,vector&lt;T&gt;&amp;A){
    for(T&amp;a:A){
        std::cin&gt;&gt;a;
    }
    return in;
}

template &lt;typename T&gt;
struct BIT{
    int n;
    vector&lt;T&gt; bit;
    BIT(int n_):n(n_){
        bit.resize(n+1);
    }

    void add(int i,T x){
        i++;
        while(i&lt;=n){
            bit[i]+=x;
            i+=i&amp;-i;
        }
    }
    T sum(int i){
        i++;
        T s=0;
        while(i&gt;0){
            s+=bit[i];
            i-=i&amp;-i;
        }
        return s;
    }
};
</code></pre>
<h1 id="列挙"><a class="header" href="#列挙">列挙</a></h1>
<h1 id="順列列挙"><a class="header" href="#順列列挙">順列列挙</a></h1>
<h2 id="概要-2"><a class="header" href="#概要-2">概要</a></h2>
<p>次を列挙できる</p>
<ul>
<li>$0,1,2,3,...,N-1$の要素数$N$個の順列，要素の重複なし</li>
<li>$0,1,2,3,...,N-1$のから$U$個選んだ順列，要素の重複なし</li>
<li>$0,1,2,3,...,N-1$のから$U$個選んだ順列，要素の重複あり</li>
<li>$0,1,2,3,...,N-1$のから$U$個選んだ組み合わせ，要素の重複なし</li>
<li>$0,1,2,3,...,N-1$のから$U$個選んだ組み合わせ，要素の重複あり</li>
</ul>
<h2 id="計算量"><a class="header" href="#計算量">計算量</a></h2>
<p>よくわからん</p>
<h2 id="ソースコード-2"><a class="header" href="#ソースコード-2">ソースコード</a></h2>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; permutations(int N){
    vector&lt;int&gt; array(N);
    vector&lt;vector&lt;int&gt;&gt; A(0);
    for(int i=0;i&lt;N;i++)array[i]=i;
    do{
        A.push_back(array);
    }while(next_permutation(array.begin(),array.end()));
    return A;
}



vector&lt;vector&lt;int&gt;&gt; permutation(int N,int U,bool h=false){
    //0,1,2,3,...,N-1のN個からU個選ぶ順列
    vector&lt;vector&lt;int&gt;&gt; A(0);
    auto fun = [&amp;h,&amp;A,&amp;N,&amp;U](auto &amp;fun,vector&lt;int&gt; &amp;B)-&gt;void{
        if((int)B.size()==U){
            auto C=B;
            do{
                A.push_back(C);
            }while(next_permutation(C.begin(),C.end()));
            return;
        }
        int s = (h?0:-1);
        if(!B.empty())s = B.back();
        for(int x=s+(h?0:1);x&lt;N;x++){
            B.push_back(x);
            fun(fun,B);
            B.pop_back();
        }
    };
    vector&lt;int&gt; C={};
    fun(fun,C);
    return A;
}

vector&lt;vector&lt;int&gt;&gt; combination(int N,int U,bool h=false){
    //0,1,2,3,...,N-1のN個からU個選ぶ組み合わせ順列
    vector&lt;vector&lt;int&gt;&gt; A(0);
    auto fun = [&amp;h,&amp;A,&amp;N,&amp;U](auto &amp;fun,vector&lt;int&gt; &amp;B)-&gt;void{
        if((int)B.size()==U){
            auto C=B;
            A.push_back(B);
            return;
        }
        int s = (h?0:-1);
        if(!B.empty())s = B.back();
        for(int x=s+(h?0:1);x&lt;N;x++){
            B.push_back(x);
            fun(fun,B);
            B.pop_back();
        }
    };
    vector&lt;int&gt; C={};
    fun(fun,C);
    return A;
}

int main(void){
    cout&lt;&lt;permutation(5,3,false)&lt;&lt;endl;//重複なし順列
    cout&lt;&lt;permutation(5,3,true)&lt;&lt;endl; //重複あり順列
    cout&lt;&lt;combination(5,3,false)&lt;&lt;endl;//重複なし組み合わせ
    cout&lt;&lt;combination(5,3,true)&lt;&lt;endl; //重複あり組み合わせ
}

</code></pre>
<h1 id="ビットの部分集合列挙"><a class="header" href="#ビットの部分集合列挙">ビットの部分集合列挙</a></h1>
<h2 id="概要-3"><a class="header" href="#概要-3">概要</a></h2>
<p>ある非負整数$x$があるとき，$x|a =x$となるような$a$を列挙する</p>
<h2 id="ソースコード-3"><a class="header" href="#ソースコード-3">ソースコード</a></h2>
<pre><code class="language-cpp">vector&lt;long&gt; bitsub(long x){
    vector&lt;long&gt; A(0);
    //xの部分集合
    for(long T=x; ; T=(T-1)&amp;x) {
        if(T==0)break;
        A.push_back(T);
    }
    return A;
}
</code></pre>
<h1 id="整数"><a class="header" href="#整数">整数</a></h1>
<h1 id="素数判定"><a class="header" href="#素数判定">素数判定</a></h1>
<h2 id="概要-4"><a class="header" href="#概要-4">概要</a></h2>
<p>素数かどうかを判定する．</p>
<h2 id="計算量-1"><a class="header" href="#計算量-1">計算量</a></h2>
<p>$O(\sqrt{N})$</p>
<h2 id="ソースコード-4"><a class="header" href="#ソースコード-4">ソースコード</a></h2>
<pre><code class="language-cpp">bool isPrime(long N){
    if(N&lt;=1)return false;
    for(long i=2;i*i&lt;=N;i++){
        if(N%i==0){
            return false;
        }
    }
    return true;
}
</code></pre>
<h1 id="素数篩"><a class="header" href="#素数篩">素数篩</a></h1>
<h2 id="概要-5"><a class="header" href="#概要-5">概要</a></h2>
<p>エラトステネスの篩．</p>
<h2 id="計算量-2"><a class="header" href="#計算量-2">計算量</a></h2>
<p>$1$から$N$までの全ての整数を素数判定する(篩の処理)場合は$\sqrt{N}\log \sqrt{N}$．
この処理をすると，</p>
<ul>
<li>$N$以下の数の素因数分解が$O(\log N)$</li>
<li><del>$N$以下の数の約数列挙が$O(\log N)$</del>(未実装)</li>
</ul>
<p>で可能になる．</p>
<h2 id="ソースコード-5"><a class="header" href="#ソースコード-5">ソースコード</a></h2>
<pre><code class="language-cpp">struct primeSieve{
    vector&lt;long&gt; mfactor;
    //既知の素数(随時追加される)
    vector&lt;long&gt; primes;
    set&lt;long&gt; primeSet;
    long N;
    primeSieve(){
        N = 0;
        calc();
    }
    primeSieve(long N){
        this-&gt; N = N;
        calc();
    }
    /*
    素数篩
    O(sqrt(N))
    */
    void calc(){
        primes.clear();
        mfactor.resize(N+1);
        fill(mfactor.begin(),mfactor.end(),-1);
        mfactor[0] = 0;
        mfactor[1] = 1;
        for(long i=2;i&lt;=N;i++){
            if(mfactor[i] == -1){
                for(long j=i;j&lt;=N;j+=i){
                    mfactor[j] = i;
                }
            }
        }
        for(long i=2;i&lt;=N;i++){
            if(mfactor[i] == i){
                primes.push_back(i);
                primeSet.insert(i);
            }
        }
    }
    /*
    素数判定
    O(1)
    */
    bool isPrime(long x){
        if(x==1)return false;
        if(x&lt;=N) return x == mfactor[x];
        if(primeSet.count(x))return true;
        return isPrimeNaive(x);
    }
    /*
    Naive素数判定
    O(sqrt(N))
    */
    bool isPrimeNaive(long x){
        if(x&lt;=1)return false;
        for(long i=2;i*i&lt;=x;i++){
            if(x%i==0){
                return false;
            }
        }
        primes.push_back(x);
        primeSet.insert(x);
        return true;
    }
    /*
    素因数分解
    O(log N)
    */
    vector&lt;long&gt; factorization(long x){
        if(x&gt;N){
            return factorizationNaive(x);
        }
        vector&lt;long&gt; A(0);
        if(x==1){
            A.push_back(1);
            return A;
        }
        while(x&gt;1){
            A.push_back(mfactor[x]);
            x /= mfactor[x];
        }
        reverse(A.begin(),A.end());
        return A;
    }
    /*
    Naive素因数分解
    O(sqrt N)
    */
    vector&lt;long&gt; factorizationNaive(long x){
        vector&lt;long&gt; A(0);
        for(long i=2;i*i&lt;=x;){
            if(x%i==0){
                x/=i;
                A.push_back(i);
            }else{
                i++;
            }
        }
        if(x&gt;1){
            A.push_back(x);
        }
        return A;
    }
}
</code></pre>
<h1 id="約数列挙"><a class="header" href="#約数列挙">約数列挙</a></h1>
<h2 id="概要-6"><a class="header" href="#概要-6">概要</a></h2>
<p>正の整数$N$の約数を列挙する</p>
<h2 id="計算量-3"><a class="header" href="#計算量-3">計算量</a></h2>
<p>$O(\sqrt{N})$</p>
<h2 id="ソースコード-6"><a class="header" href="#ソースコード-6">ソースコード</a></h2>
<pre><code class="language-cpp">//約数列挙
vector&lt;long&gt; divisor(long x){
    vector&lt;long&gt; f(0);
    for(long i=1;i*i&lt;=x;i++){
        if(x%i==0){
            f.push_back(i);
            if(i!=x/i)f.push_back(x/i);
        }
    }
    sort(f.begin(),f.end());
    return f;
}
</code></pre>
<h1 id="素因数分解"><a class="header" href="#素因数分解">素因数分解</a></h1>
<h2 id="概要-7"><a class="header" href="#概要-7">概要</a></h2>
<p>$2$以上の正の整数$N$の素因数分解する</p>
<h2 id="計算量-4"><a class="header" href="#計算量-4">計算量</a></h2>
<p>$O(\sqrt{N})$</p>
<h2 id="ソースコード-7"><a class="header" href="#ソースコード-7">ソースコード</a></h2>
<pre><code class="language-cpp">//素因数分解
vector&lt;long&gt; factor(long x){
    vector&lt;long&gt; f(0);
    for(long i=2;i*i&lt;=x;i++){
        if(x%i==0){
            f.push_back(i);
            x/=i;
            i--;
        }
    }
    if(x&gt;1)f.push_back(x);
    return f;
}

//素因数分解2
// (素数,指数) のpair
vector&lt;pair&lt;long,long&gt;&gt; factor2(long x){
    auto f = factor(x);
    vector&lt;pair&lt;long,long&gt;&gt; f2(0);
    for(auto a:f){
        if(f2.empty()){
            f2.push_back({a,1});
        }else if(f2.back().first==a){
            f2.back().second ++;
        }else{
            f2.push_back({a,1});
        }
    }
    return f2;
}
</code></pre>
<h1 id="累乗根"><a class="header" href="#累乗根">累乗根</a></h1>
<h2 id="概要-8"><a class="header" href="#概要-8">概要</a></h2>
<p>$y,n$から$x^n\leq y$を満たすような最大の整数$x$を求める．</p>
<h2 id="計算量-5"><a class="header" href="#計算量-5">計算量</a></h2>
<p>$O(\log N)$</p>
<h2 id="ソースコード-8"><a class="header" href="#ソースコード-8">ソースコード</a></h2>
<pre><code class="language-cpp">long iroot(long y,int n){
    //x^n &lt;= yとなる最大のn
    long ok = 0;
    long ng = y+1;
    while(abs(ok-ng)&gt;1){
        long mid = (ok+ng)/2;
        long x = 1;
        bool inf = false;
        for(int i=0;i&lt;n;i++){
            if(((long)1e18)/x &lt; mid)inf = true;
            x *= mid;
        }
        if(inf||x&gt;y){
            ng = mid;
        }else{
            ok = mid;
        }
    }
    return ok;
}
</code></pre>
<h1 id="2次方程式"><a class="header" href="#2次方程式">2次方程式</a></h1>
<h2 id="概要-9"><a class="header" href="#概要-9">概要</a></h2>
<p>$x$に関する方程式$ax^2+bx+c=0$を整数の範囲で代数的に解く．</p>
<h2 id="ソースコード-9"><a class="header" href="#ソースコード-9">ソースコード</a></h2>
<pre><code class="language-cpp">long iroot(long y,int n){
    //x^n &lt;= yとなる最大のn
    long ok = 0;
    long ng = y+1;
    while(abs(ok-ng)&gt;1){
        long mid = (ok+ng)/2;
        long x = 1;
        bool inf = false;
        for(int i=0;i&lt;n;i++){
            if(((long)1e18)/x &lt; mid)inf = true;
            x *= mid;
        }
        if(inf||x&gt;y){
            ng = mid;
        }else{
            ok = mid;
        }
    }
    return ok;
}

//整数の範囲でax^2+bx+c=0を解く
vector&lt;long&gt; quad(long a,long b,long c){
    long d=b*b-4*a*c;
    if(d&lt;0)return {}; //解なし
    long sqrtd=iroot(d,2);
    if(sqrtd*sqrtd!=d)return {}; //整数解はない
    if((sqrtd-b)%2!=0)return {}; //整数解はない
    if(sqrtd==0)return {(-b)/(2*a)}; //重解
    return {(-b+sqrtd)/(2*a),(-b-sqrtd)/(2*a)};
}


int main(void){
    auto x=quad(1,2,1);//x^2+2x+1=0
    cout&lt;&lt;x&lt;&lt;endl;// {-1}
    x=quad(1,2,2);//x^2+2x+2=0
    cout&lt;&lt;x&lt;&lt;endl;// {}
    x=quad(2,-12,-182);//2x^2-12x-182=0
    cout&lt;&lt;x&lt;&lt;endl;//{13,-7}
}
</code></pre>
<h1 id="パスカルの3角形"><a class="header" href="#パスカルの3角形">パスカルの3角形</a></h1>
<h2 id="概要-10"><a class="header" href="#概要-10">概要</a></h2>
<p>パスカルの三角形によって二項係数${}_a \mathrm{C}_b (0\leq a,b\leq N )$を求める．</p>
<h2 id="計算量-6"><a class="header" href="#計算量-6">計算量</a></h2>
<p>前計算$O(N^2)$，クエリ$O(1)$</p>
<h2 id="ソースコード-10"><a class="header" href="#ソースコード-10">ソースコード</a></h2>
<pre><code class="language-cpp">struct Pascal{
    //tri[a][b] = aCb
    vector&lt;vector&lt;long&gt;&gt; tri;
    int N;
    Pascal(int N){
        this-&gt;N = N;
        init();
    }
    void init(){
        tri.clear();
        tri.push_back({1});
        for(int i=1;i&lt;N;i++){
            vector&lt;long&gt; add(0);
            add.push_back(1);
            for(int k=0;k&lt;i-1;k++){
                add.push_back(tri.back()[k]+tri.back()[k+1]);
            }
            add.push_back(1);
            tri.push_back(add);
        }
    }
    long com(int a,int b){
        if(a&lt;b)return 0;
        return tri[a][b];
    }
};
</code></pre>
<h1 id="modint構造体"><a class="header" href="#modint構造体">modint構造体</a></h1>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p><a href="https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp">https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp</a></p>
<h2 id="ソースコード-11"><a class="header" href="#ソースコード-11">ソースコード</a></h2>
<pre><code class="language-cpp">// modint: mod 計算を int を扱うように扱える構造体
template&lt;int MOD&gt; struct Fp {
    long long val;
    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {
        if (val &lt; 0) val += MOD;
    }
    constexpr int getmod() { return MOD; }
    constexpr Fp operator - () const noexcept {
        return val ? MOD - val : 0;
    }
    constexpr Fp operator + (const Fp&amp; r) const noexcept { return Fp(*this) += r; }
    constexpr Fp operator - (const Fp&amp; r) const noexcept { return Fp(*this) -= r; }
    constexpr Fp operator * (const Fp&amp; r) const noexcept { return Fp(*this) *= r; }
    constexpr Fp operator / (const Fp&amp; r) const noexcept { return Fp(*this) /= r; }
    constexpr Fp&amp; operator += (const Fp&amp; r) noexcept {
        val += r.val;
        if (val &gt;= MOD) val -= MOD;
        return *this;
    }
    constexpr Fp&amp; operator -= (const Fp&amp; r) noexcept {
        val -= r.val;
        if (val &lt; 0) val += MOD;
        return *this;
    }
    constexpr Fp&amp; operator *= (const Fp&amp; r) noexcept {
        val = val * r.val % MOD;
        return *this;
    }
    constexpr Fp&amp; operator /= (const Fp&amp; r) noexcept {
        long long a = r.val, b = MOD, u = 1, v = 0;
        while (b) {
            long long t = a / b;
            a -= t * b; swap(a, b);
            u -= t * v; swap(u, v);
        }
        val = val * u % MOD;
        if (val &lt; 0) val += MOD;
        return *this;
    }
    constexpr bool operator == (const Fp&amp; r) const noexcept {
        return this-&gt;val == r.val;
    }
    constexpr bool operator != (const Fp&amp; r) const noexcept {
        return this-&gt;val != r.val;
    }
    friend constexpr ostream&amp; operator &lt;&lt; (ostream &amp;os, const Fp&lt;MOD&gt;&amp; x) noexcept {
        return os &lt;&lt; x.val;
    }
    friend constexpr Fp&lt;MOD&gt; modpow(const Fp&lt;MOD&gt; &amp;a, long long n) noexcept {
        if (n == 0) return 1;
        auto t = modpow(a, n / 2);
        t = t * t;
        if (n &amp; 1) t = t * a;
        return t;
    }
};

</code></pre>
<h1 id="実行時に法が決まるmodint構造体"><a class="header" href="#実行時に法が決まるmodint構造体">実行時に法が決まるmodint構造体</a></h1>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<p><a href="https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod_runtime.cpp">https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod_runtime.cpp</a></p>
<h2 id="ソースコード-12"><a class="header" href="#ソースコード-12">ソースコード</a></h2>
<pre><code class="language-cpp">// modint: mod 計算を int を扱うように扱える構造体
template&lt;int MOD&gt; struct Fp {
    long long val;
    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {
        if (val &lt; 0) val += MOD;
    }
    constexpr int getmod() { return MOD; }
    constexpr Fp operator - () const noexcept {
        return val ? MOD - val : 0;
    }
    constexpr Fp operator + (const Fp&amp; r) const noexcept { return Fp(*this) += r; }
    constexpr Fp operator - (const Fp&amp; r) const noexcept { return Fp(*this) -= r; }
    constexpr Fp operator * (const Fp&amp; r) const noexcept { return Fp(*this) *= r; }
    constexpr Fp operator / (const Fp&amp; r) const noexcept { return Fp(*this) /= r; }
    constexpr Fp&amp; operator += (const Fp&amp; r) noexcept {
        val += r.val;
        if (val &gt;= MOD) val -= MOD;
        return *this;
    }
    constexpr Fp&amp; operator -= (const Fp&amp; r) noexcept {
        val -= r.val;
        if (val &lt; 0) val += MOD;
        return *this;
    }
    constexpr Fp&amp; operator *= (const Fp&amp; r) noexcept {
        val = val * r.val % MOD;
        return *this;
    }
    constexpr Fp&amp; operator /= (const Fp&amp; r) noexcept {
        long long a = r.val, b = MOD, u = 1, v = 0;
        while (b) {
            long long t = a / b;
            a -= t * b; swap(a, b);
            u -= t * v; swap(u, v);
        }
        val = val * u % MOD;
        if (val &lt; 0) val += MOD;
        return *this;
    }
    constexpr bool operator == (const Fp&amp; r) const noexcept {
        return this-&gt;val == r.val;
    }
    constexpr bool operator != (const Fp&amp; r) const noexcept {
        return this-&gt;val != r.val;
    }
    friend constexpr ostream&amp; operator &lt;&lt; (ostream &amp;os, const Fp&lt;MOD&gt;&amp; x) noexcept {
        return os &lt;&lt; x.val;
    }
    friend constexpr Fp&lt;MOD&gt; modpow(const Fp&lt;MOD&gt; &amp;a, long long n) noexcept {
        if (n == 0) return 1;
        auto t = modpow(a, n / 2);
        t = t * t;
        if (n &amp; 1) t = t * a;
        return t;
    }
};

</code></pre>
<h1 id="二項係数mod"><a class="header" href="#二項係数mod">二項係数(mod)</a></h1>
<h2 id="概要-11"><a class="header" href="#概要-11">概要</a></h2>
<p>二項係数${}_a \mathrm{C}_b (0\leq a,b\leq N )$を素数$P$で割った余りを求める．</p>
<h2 id="計算量-7"><a class="header" href="#計算量-7">計算量</a></h2>
<p>前計算$O(N\log P)$，クエリ$O(1)$</p>
<h2 id="ソースコード-13"><a class="header" href="#ソースコード-13">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct Combination{
    int N;
    vector&lt;T&gt; fac;//階乗
    vector&lt;T&gt; finv;//階乗の逆元
    Combination(int N){
        this-&gt;N = N;
        init();
    }
    void init(){
        fac.resize(N);
        finv.resize(N);
        fac[0] = fac[1] = 1;
        finv[0] = finv[1] = 1;
        for(int i=2;i&lt;N;i++){
            fac[i] = fac[i-1] * i;
            finv[i] = finv[i-1] / i;
        }
    }
    /*aCbの計算*/
    T com(int a,int b){
        if(a &lt; b)return 0;
        return fac[a] * finv[b] * finv[a-b];
    }
};

</code></pre>
<h1 id="ルーカスの定理による二項係数"><a class="header" href="#ルーカスの定理による二項係数">ルーカスの定理による二項係数</a></h1>
<h2 id="概要-12"><a class="header" href="#概要-12">概要</a></h2>
<p>ルーカスの定理によって二項係数を素数$P$で割った余りを計算する．</p>
<h2 id="計算量-8"><a class="header" href="#計算量-8">計算量</a></h2>
<p>前計算$O(P^2)$，二項係数計算に$O(\log P) $</p>
<h2 id="ソースコード-14"><a class="header" href="#ソースコード-14">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;int MOD&gt; struct Lucas{
    Pascal pas{MOD};
    Lucas(){
    }
    Fp&lt;MOD&gt; com(long a,long b){
        if(a&lt;b)return 0;
        Fp&lt;MOD&gt; ret{1};
        while(a&gt;0){
            ret *=pas.com(a%MOD,b%MOD);
            a/=MOD;
            b/=MOD;
        }
        return ret;
    }
};

</code></pre>
<h1 id="2元1次不定方程式"><a class="header" href="#2元1次不定方程式">2元1次不定方程式</a></h1>
<h2 id="概要-13"><a class="header" href="#概要-13">概要</a></h2>
<p>非負整数$a,b$に対して$ax + by = 1$ を解く．一般解が求められる．</p>
<h2 id="ソースコード-15"><a class="header" href="#ソースコード-15">ソースコード</a></h2>
<pre><code class="language-cpp">// 返り値: a と b の最大公約数
// ax + by = gcd(a, b) を満たす (x, y) が格納される
long extGCD(long a, long b, long &amp;x, long &amp;y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long d = extGCD(b, a%b, y, x);
    y -= a/b * x;
    return d;
}
/*
ax + by = c の一般解
x = alpha t + beta
y = gamma t + delta
*/
bool Bezout(long a,long b,long c,long &amp;alpha,long &amp;beta,long &amp;gamma,long &amp;delta){
    long x=0,y=0;
    long gcd=extGCD(a,b,x,y);
    if(c%gcd!=0){
        return false;
    }
    x *= c/gcd;
    y *= c/gcd;
    gamma = a/gcd;
    delta = y;
    alpha = -b/gcd;
    beta = x;
    return true;
}

</code></pre>
<h1 id="lcdgcd"><a class="header" href="#lcdgcd">LCD,GCD</a></h1>
<h2 id="概要-14"><a class="header" href="#概要-14">概要</a></h2>
<p>最大公約数(GCD)，最小公倍数(LCM)を求める</p>
<h2 id="計算量-9"><a class="header" href="#計算量-9">計算量</a></h2>
<h2 id="ソースコード-16"><a class="header" href="#ソースコード-16">ソースコード</a></h2>
<pre><code class="language-cpp">
long GCD(long a,long b){
    if(a&lt;b)return GCD(b,a);
    if(b==0)return a;
    return GCD(b,a%b);
}

long GCD(vector&lt;long&gt;&amp;A){
    long gcd = A.front();
    for(auto&amp;a:A)gcd = GCD(gcd,a);
    return gcd;
}

long LCM(long a,long b){
    return (a/GCD(a,b))*b;
}


long LCM(vector&lt;long&gt;&amp;A){
    long lcm = 1;
    for(auto&amp;a:A)lcm = LCM(lcm,a);
    return lcm;
}

</code></pre>
<h1 id="中国剰余定理"><a class="header" href="#中国剰余定理">中国剰余定理</a></h1>
<h2 id="概要-15"><a class="header" href="#概要-15">概要</a></h2>
<p>$a$で割った余りが$b$，$c$で割った余りが$d$を満たす数を求める．</p>
<h2 id="ソースコード-17"><a class="header" href="#ソースコード-17">ソースコード</a></h2>
<pre><code class="language-cpp">// 返り値: a と b の最大公約数
// ax + by = gcd(a, b) を満たす (x, y) が格納される
long extGCD(long a, long b, long &amp;x, long &amp;y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long d = extGCD(b, a%b, y, x);
    y -= a/b * x;
    return d;
}

long mod(long a,long m){
    if(a&gt;=0)return a%m; 
    return (m-(-a)%m)%m;
}

/*
中国剰余定理
*/
bool CRT(long b1, long m1, long b2, long m2,long &amp;r,long &amp;m) {
    long p, q;
    long d = extGCD(m1, m2, p, q);
    if ((b2 - b1) % d != 0) return false;
    m = m1 * (m2/d); 
    long tmp = (b2 - b1) / d * p % (m2/d);
    r = mod(b1 + m1 * tmp, m);
    return true;
}

bool CRT(const vector&lt;pair&lt;long,long&gt;&gt; &amp;X,long &amp;r,long &amp;m) {
    int s = X.size();
    r = X.front().first;
    m = X.front().second;
    bool ok = true;
    for(int i=1;i&lt;s;i++){
        ok = CRT(r,m,X[i].first,X[i].second,r,m);
        if(!ok){
            break;
        }
    }
    return ok;
}
</code></pre>
<h1 id="baby-step-giant-step"><a class="header" href="#baby-step-giant-step">baby step giant step</a></h1>
<h2 id="概要-16"><a class="header" href="#概要-16">概要</a></h2>
<p>素数$p$と$0\leq a,b&lt; p $について，$a^x = b \mod p$となる$x$を求める．</p>
<h2 id="計算量-10"><a class="header" href="#計算量-10">計算量</a></h2>
<p>$O(\sqrt{p} \log \sqrt{p})$</p>
<h2 id="ソースコード-18"><a class="header" href="#ソースコード-18">ソースコード</a></h2>
<pre><code class="language-cpp">long  extgcd(long a,long b,long &amp; x,long &amp; y){
    long d = a;
    if(b != 0) {
        d = extgcd(b,a%b,y,x);
        y -= (a/b) * x;
    }else{
        x = 1; y = 0;
    }
    return d;
}

long mod_inverse(long a,long m){
    long x,y;
    extgcd(a,m,x,y);
    return (m + x % m) % m;
}

int modPow(long a, long n, long p) {
  if (n == 0) return 1; // 0乗にも対応する場合
  if (n == 1) return a % p;
  if (n % 2 == 1) return (a * modPow(a, n - 1, p)) % p;
  long t = modPow(a, n / 2, p);
  return (t * t) % p;
}

long iroot(long y,int n){
    //x^n &lt;= yとなる最大のn
    long ok = 0;
    long ng = y+1;
    while(abs(ok-ng)&gt;1){
        long mid = (ok+ng)/2;
        long x = 1;
        bool inf = false;
        for(int i=0;i&lt;n;i++){
            if(((long)1e18)/x &lt; mid)inf = true;
            x *= mid;
        }
        if(inf||x&gt;y){
            ng = mid;
        }else{
            ok = mid;
        }
    }
    return ok;
}

long BSGS(long a,long b,long p){
    /* a^x = b mod p となるようなxを求める */
    long x = -1;
    long m = iroot(p,2)+1;
    map&lt;long,long&gt; mp;
    long ax = 1;
    for(long i=0;i&lt;=m;i++){
        mp[ax] = i;
        ax = (ax*a) % p;
    }
    /*
    a^(im+j) = b
    a^j = b(a^-m)^i
    */
    long am = modPow(mod_inverse(a,p),m,p);
    for(long i=0;i&lt;=m;i++){
        long d = (modPow(am,i,p)*b) % p;
        if(mp.count(d)){
            if(i==0&amp;&amp;mp[d]==0)continue;
            x = i*m + mp[d];
            break;
        }
    }
    return x;
}
</code></pre>
<h1 id="中国剰余定理garners-algorithm"><a class="header" href="#中国剰余定理garners-algorithm">❌中国剰余定理(Garner's algorithm)</a></h1>
<h1 id="cipollas-algorithm"><a class="header" href="#cipollas-algorithm">❌Cipolla's algorithm</a></h1>
<h1 id="線形代数"><a class="header" href="#線形代数">線形代数</a></h1>
<h1 id="3次元ベクトル構造体"><a class="header" href="#3次元ベクトル構造体">3次元ベクトル構造体</a></h1>
<h2 id="概要-17"><a class="header" href="#概要-17">概要</a></h2>
<p>3次元ベクトルの加算減算，外積が計算できる</p>
<h2 id="ソースコード-19"><a class="header" href="#ソースコード-19">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct Vector3D{
    T x{0};
    T y{0};
    T z{0};
    constexpr Vector3D(T x,T y,T z){
        this -&gt; x = x;
        this -&gt; y = y;
        this -&gt; z = z;
    }
    constexpr Vector3D(T x1,T y1,T z1,T x2,T y2,T z2){
        this -&gt; x = x2 - x1;
        this -&gt; y = y2 - y1;
        this -&gt; z = z2 - z1;
    }
    constexpr Vector3D cross(const Vector3D &amp;a)const{
        return Vector3D(this-&gt;y * a.z - this-&gt;z * a.y, this-&gt;z * a.x - this-&gt;x * a.z, this-&gt;x * a.y - this-&gt;y * a.x);
    }
    constexpr Vector3D operator-(const Vector3D &amp;r)const{
        return Vector3D(*this)-=r;
    }
    constexpr Vector3D operator-=(const Vector3D &amp;r){
        this-&gt;x -= r.x;
        this-&gt;y -= r.y;
        this-&gt;z -= r.z;
        return *this;
    }
    constexpr Vector3D operator+(const Vector3D &amp;r){
        return Vector3D(*this)+=r;
    }
    constexpr Vector3D operator+=(const Vector3D &amp;r){
        this-&gt;x += r.x;
        this-&gt;y += r.y;
        this-&gt;z += r.z;
        return *this;
    }
    constexpr bool operator==(const Vector3D &amp;r) const{
        return this-&gt;x == r.x &amp;&amp; this-&gt;y == r.y &amp;&amp; this-&gt;z == r.z;
    }
    friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,const Vector3D &amp;a){
        out&lt;&lt;&quot;{&quot;&lt;&lt;a.x&lt;&lt;&quot;, &quot;&lt;&lt;a.y&lt;&lt;&quot;, &quot;&lt;&lt;a.z&lt;&lt;&quot;}&quot;;
        return out;
    }
};

</code></pre>
<h1 id="行列"><a class="header" href="#行列">行列</a></h1>
<h2 id="概要-18"><a class="header" href="#概要-18">概要</a></h2>
<h2 id="ソースコード-20"><a class="header" href="#ソースコード-20">ソースコード</a></h2>
<p><a href="https://github.com/drken1215/algorithm/blob/master/MathAlgebra/matrix.cpp">参考</a></p>
<pre><code class="language-cpp">// matrix
template&lt;class T&gt; struct Matrix {
    vector&lt;vector&lt;T&gt; &gt; val;
    Matrix(int n = 1, int m = 1, T v = 0) : val(n, vector&lt;T&gt;(m, v)) {}
    void init(int n, int m, T v = 0) {val.assign(n, vector&lt;T&gt;(m, v));}
    void resize(int n, int m) {
        val.resize(n);
        for (int i = 0; i &lt; n; ++i) val[i].resize(m);
    }
    Matrix&lt;T&gt;&amp; operator = (const Matrix&lt;T&gt; &amp;A) {
        val = A.val;
        return *this;
    }
    size_t size() const {return val.size();}
    vector&lt;T&gt;&amp; operator [] (int i) {return val[i];}
    const vector&lt;T&gt;&amp; operator [] (int i) const {return val[i];}
    friend ostream&amp; operator &lt;&lt; (ostream&amp; s, const Matrix&lt;T&gt;&amp; M) {
        s &lt;&lt; endl;
        for (int i = 0; i &lt; (int)M.size(); ++i) s &lt;&lt; M[i] &lt;&lt; endl;
        return s;
    }
};

template&lt;class T&gt; Matrix&lt;T&gt; operator * (const Matrix&lt;T&gt; &amp;A, const Matrix&lt;T&gt; &amp;B) {
    Matrix&lt;T&gt; R(A.size(), B[0].size());
    for (int i = 0; i &lt; A.size(); ++i)
        for (int j = 0; j &lt; B[0].size(); ++j)
            for (int k = 0; k &lt; B.size(); ++k)
                R[i][j] += A[i][k] * B[k][j];
    return R;
}

template&lt;class T&gt; Matrix&lt;T&gt; pow(const Matrix&lt;T&gt; &amp;A, long long n) {
    Matrix&lt;T&gt; R(A.size(), A.size());
    auto B = A;
    for (int i = 0; i &lt; A.size(); ++i) R[i][i] = 1;
    while (n &gt; 0) {
        if (n &amp; 1) R = R * B;
        B = B * B;
        n &gt;&gt;= 1;
    }
    return R;
}

template&lt;class T&gt; vector&lt;T&gt; operator * (const Matrix&lt;T&gt; &amp;A, const vector&lt;T&gt; &amp;B) {
    vector&lt;T&gt; v(A.size());
    for (int i = 0; i &lt; A.size(); ++i)
        for (int k = 0; k &lt; B.size(); ++k)
            v[i] += A[i][k] * B[k];
    return v;
}

template&lt;class T&gt; Matrix&lt;T&gt; operator + (const Matrix&lt;T&gt; &amp;A, const Matrix&lt;T&gt; &amp;B) {
    Matrix&lt;T&gt; R(A.size(), A[0].size());
    for (int i = 0; i &lt; A.size(); ++i)
        for (int j = 0; j &lt; A[0].size(); ++j)
            R[i][j] = A[i][j] + B[i][j];
    return R;
}

template&lt;class T&gt; Matrix&lt;T&gt; operator - (const Matrix&lt;T&gt; &amp;A, const Matrix&lt;T&gt; &amp;B) {
    Matrix&lt;T&gt; R(A.size(), A[0].size());
    for (int i = 0; i &lt; A.size(); ++i)
        for (int j = 0; j &lt; A[0].size(); ++j)
            R[i][j] = A[i][j] - B[i][j];
    return R;
}

</code></pre>
<h1 id="分数"><a class="header" href="#分数">❌分数</a></h1>
<h1 id="幾何"><a class="header" href="#幾何">幾何</a></h1>
<h1 id="円同士の当たり判定"><a class="header" href="#円同士の当たり判定">❌円同士の当たり判定</a></h1>
<h1 id="線分の交差判定"><a class="header" href="#線分の交差判定">線分の交差判定</a></h1>
<h2 id="概要-19"><a class="header" href="#概要-19">概要</a></h2>
<p>線分同士が共通する点を持つかを判定．</p>
<h2 id="ソースコード-21"><a class="header" href="#ソースコード-21">ソースコード</a></h2>
<pre><code class="language-cpp">
inline bool rangeInRange(long l0,long r0,long l1,long r1){
    if(l0&gt;r0)swap(l0,r0);
    if(l1&gt;r1)swap(l1,r1);
    if(l1&lt;l0&amp;&amp;r1&lt;l0)return false;
    if(r0&lt;l1&amp;&amp;r0&lt;r1)return false;
    return true;
}

inline long getSign(long a){
    if(a&gt;0)return 1;
    else if(a&lt;0)return -1;
    return 0;
}

bool isIntersects(long x1,long y1,long x2,long y2,long x3,long y3,long x4,long y4){
    using Vec3 = Vector3D&lt;long&gt;;
    Vec3 A{x1,y1,0};
    Vec3 B{x2,y2,0};
    Vec3 C{x3,y3,0};
    Vec3 D{x4,y4,0};
    auto AB=B-A;
    auto AC=C-A;
    auto AD=D-A;
    auto CD=D-C;
    auto CA=A-C;
    auto CB=B-C;
    long a = getSign(AB.cross(AC).z);
    long b = getSign(AB.cross(AD).z);
    long c = getSign(CD.cross(CA).z);
    long d = getSign(CD.cross(CB).z);
    bool intersects = (a*b&lt;=0&amp;&amp;c*d&lt;=0);
    if(a==0&amp;&amp;b==0){
        intersects = rangeInRange(A.x,B.x,C.x,D.x) &amp;&amp; rangeInRange(A.y,B.y,C.y,D.y);
    }
    return intersects;
}
</code></pre>
<h1 id="凸包"><a class="header" href="#凸包">❌凸包</a></h1>
<h1 id="数列"><a class="header" href="#数列">数列</a></h1>
<h1 id="等差数列"><a class="header" href="#等差数列">等差数列</a></h1>
<h2 id="概要-20"><a class="header" href="#概要-20">概要</a></h2>
<p>$O(1)$で等差数列の次の項目を求める．</p>
<ul>
<li>第$n$項までの和</li>
<li>第$n$項はいくつか</li>
<li>第$l$項目から第$r$項目までの和</li>
<li>$b$は何項目であるか</li>
</ul>
<h2 id="ソースコード-22"><a class="header" href="#ソースコード-22">ソースコード</a></h2>
<pre><code class="language-cpp">//初項s公差d第n項までの和
long arithSum(long a,long d,long n){
    return n*(2*a+(n-1)*d)/2;
}

//初項s公差dの第n項
long arith(long a,long d,long n){
    return a + d*(n-1);
}

//初項a公差d第l項から第r項までの和
long arithSumRange(long a,long d,long l,long r){
    //第l項が初項となるような数列を作る．
    return arithSum(arith(a,d,l),d,r-l+1);
}

//初項aで公差dのときbは第何項であるか．
long arithWhere(long a,long d,long b){
    if(d==0){
        if(a==b)return 1;
        return -1;
    }
    // a+d*(n-1) = bとなるようなnが存在するか
    // a + dn - d = b
    // n = (b + d - a)/d
    if((b+d-a)%d==0 &amp;&amp; (b+d-a)/d &gt; 0 )return (b+d-a)/d;
    return -1;
}



//

</code></pre>
<h2 id="実行例"><a class="header" href="#実行例">実行例</a></h2>
<pre><code class="language-cpp">int main(void){
    long a,d;
    /*
        a = 2
        d = 3
        2,5,8,11,14,17,20,...
    */
    a = 2,d = 3;
    cout&lt;&lt;arith(a,d,4)&lt;&lt;endl;
    cout&lt;&lt;arithSum(a,d,5)&lt;&lt;endl;
    cout&lt;&lt;arithSumRange(a,d,3,6)&lt;&lt;endl;
    cout&lt;&lt;arithWhere(a,d,20)&lt;&lt;endl;
    /*
        a = 10
        d = -5
        10,5,0,-5,-10,-15,...
    */
    a = 10,d = -5;
    cout&lt;&lt;arith(a,d,4)&lt;&lt;endl;
    cout&lt;&lt;arithSum(a,d,5)&lt;&lt;endl;
    cout&lt;&lt;arithSumRange(a,d,3,6)&lt;&lt;endl;
    cout&lt;&lt;arithWhere(a,d,15)&lt;&lt;endl;

    deque&lt;int&gt; qu
}
</code></pre>
<p>実行結果</p>
<pre><code class="language-cpp">11
40
50
7
-5
0
-30
-1
</code></pre>
<h1 id="等比数列"><a class="header" href="#等比数列">等比数列</a></h1>
<h1 id="階差数列"><a class="header" href="#階差数列">階差数列</a></h1>
<h1 id="多項式"><a class="header" href="#多項式">多項式</a></h1>
<h1 id="畳み込み"><a class="header" href="#畳み込み">畳み込み</a></h1>
<h2 id="概要-21"><a class="header" href="#概要-21">概要</a></h2>
<p>多項式の掛け算が高速にできる．</p>
<h2 id="ソースコード-23"><a class="header" href="#ソースコード-23">ソースコード</a></h2>
<ul>
<li><a href="https://atcoder.github.io/ac-library/production/document_ja/convolution.html">AtCoder Libraryの畳み込み(強い)</a></li>
<li><a href="https://atcoder.jp/contests/atc001/submissions/27756384">なぜかC言語で実装したやつ(FFT)</a></li>
<li><a href="https://atcoder.jp/contests/atc001/submissions/27762284">なぜかC言語で実装したやつ(NTT)</a></li>
</ul>
<h1 id="形式的冪級数"><a class="header" href="#形式的冪級数">❌形式的冪級数</a></h1>
<h1 id="文字列"><a class="header" href="#文字列">文字列</a></h1>
<h1 id="rolling-hash"><a class="header" href="#rolling-hash">Rolling Hash</a></h1>
<h2 id="概要-22"><a class="header" href="#概要-22">概要</a></h2>
<p>文字列$S$で，連続した部分文字列のハッシュ値を計算する．</p>
<h2 id="計算量-11"><a class="header" href="#計算量-11">計算量</a></h2>
<ul>
<li>前計算: $O(|S|)$</li>
<li>ハッシュ値計算: $O(1)$</li>
</ul>
<h2 id="ソースコード-24"><a class="header" href="#ソースコード-24">ソースコード</a></h2>
<pre><code class="language-cpp">/*HashRolling*/
template&lt;class T&gt; class RollingHash{
    public:
    vector&lt;T&gt; hash,pow;
    RollingHash(vector&lt;T&gt; &amp;A,T base){
        int N = (int)A.size();
        hash.resize(N+1);
        pow.resize(N+1);
        pow[0]=1;
        for(int i=0;i&lt;N;i++){
            hash[i+1]=hash[i]*base+A[i];
            pow[i+1]=pow[i]*base;
        }
    }
    T get(int l,int r){
        return hash[r]-hash[l]*pow[r-l];
    }
};
</code></pre>
<h1 id="z-algorithm"><a class="header" href="#z-algorithm">Z Algorithm</a></h1>
<h2 id="概要-23"><a class="header" href="#概要-23">概要</a></h2>
<p>文字列$S$の各位置$i$について，「$S$」と「$S$の$i$文字目以降の文字列」の最長共通接頭辞の長さを求めるアルゴリズム．</p>
<h2 id="計算量-12"><a class="header" href="#計算量-12">計算量</a></h2>
<p>$O(|S|)$</p>
<h2 id="ソースコード-25"><a class="header" href="#ソースコード-25">ソースコード</a></h2>
<pre><code class="language-cpp">/*Z-Algorithm*/
vector&lt;int&gt; Z_algorithm(string S){
    int N=S.size();
    vector&lt;int&gt; A(N);
    A[0]=N;
    int i=1,j=0;
    while(i&lt;N){
        while(i+j&lt;N&amp;&amp;S[j]==S[i+j])j++;
        A[i]=j;
        if(j==0){
            i++;
            continue;
        }
        int k=1;
        while(i+k&lt;N&amp;&amp;k+A[k]&lt;j){
            A[i+k]=A[k];
            k++;
        }
        i+=k;
        j-=k;
    }
    return A;
};

</code></pre>
<h1 id="sufiix-array"><a class="header" href="#sufiix-array">❌sufiix array</a></h1>
<h1 id="グラフ理論"><a class="header" href="#グラフ理論">グラフ理論</a></h1>
<h1 id="ダイクストラ法"><a class="header" href="#ダイクストラ法">ダイクストラ法</a></h1>
<h2 id="概要-24"><a class="header" href="#概要-24">概要</a></h2>
<p>重みが非負の辺のみで構成されるグラフで，2頂点間のパスの内の辺の重みの総和が最小となる値を求めるアルゴリズム</p>
<h2 id="計算量-13"><a class="header" href="#計算量-13">計算量</a></h2>
<p>頂点数を$V$，辺の数を$E$とすると，$O(E+V\log V)$ である．</p>
<p>各辺は高々1回までしか通らず，$V$個の頂点についてプライオリティーキューで高々$V$個の頂点を管理しているため．</p>
<h2 id="ソースコード-26"><a class="header" href="#ソースコード-26">ソースコード</a></h2>
<pre><code class="language-cpp">struct Edge{
    int to;
    long cost;
};

struct WeightedVertex{
    int v;
    long cost;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;;

void dijkstra(int s,Graph &amp;G,vector&lt;long&gt;&amp;D){
    auto comp = [](WeightedVertex &amp;l,WeightedVertex &amp;r){return l.cost &gt; r.cost;};
    priority_queue &lt; 
        WeightedVertex,
        vector&lt;WeightedVertex&gt;,
        function&lt;bool(WeightedVertex&amp;,WeightedVertex&amp;)&gt;
        &gt; qu (comp);
    D.resize(G.size());
    fill(D.begin(),D.end(),-1);
    D[s] = 0;
    qu.push({s,0});
    while(!qu.empty()){
        auto a = qu.top(); qu.pop();
        int from = a.v;
        for(auto&amp;e:G[from]){
            if(D[e.to] == -1 || D[e.to] &gt; D[from] + e.cost){
                D[e.to] = D[from] + e.cost;
                qu.push({e.to,D[e.to]});
            }
        }
    }
}
</code></pre>
<h1 id="ベルマンフォード法"><a class="header" href="#ベルマンフォード法">ベルマンフォード法</a></h1>
<h2 id="概要-25"><a class="header" href="#概要-25">概要</a></h2>
<p>2頂点間のパスの内の辺の重みの総和が最小となる値を求めるアルゴリズム</p>
<p>ダイクストラと違って負の辺がある場合も正しく動作，負の閉路の検出ができる．</p>
<h2 id="計算量-14"><a class="header" href="#計算量-14">計算量</a></h2>
<p>頂点数を$V$，辺の数を$E$とすると，$O(VE)$ である．</p>
<p>全ての頂点から全ての辺を見ているため．</p>
<h2 id="ソースコード-27"><a class="header" href="#ソースコード-27">ソースコード</a></h2>
<pre><code class="language-cpp">struct Edge{
    int from;
    int to;
    long cost;
};

struct WeightedVertex{
    int v;
    long cost;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;; //隣接グラフ

const long INF = 1e17; 

/*
重みはlong型
始点s，グラフGの点をDに
戻り値は **sからgの経路** を作るときに重みが負の無限になるか
*/
bool bellmanFord(int s,int g,Graph &amp;G,vector&lt;long&gt;&amp;D){
    const int N = G.size();
    vector&lt;Edge&gt;edges;
    for(auto A:G){
        for(Edge&amp; a:A){
            edges.push_back(a);
        }
    }
    fill(D.begin(),D.end(),INF);
    D[s] = 0;
    for(int i=0;i&lt;=N;i++){
        for(auto&amp;e:edges){
            long d = D[e.from] + e.cost;
            if(D[e.from] &lt; INF &amp;&amp; D[e.to] &gt; d){
                D[e.to] = d;
                if(i==N&amp;&amp;e.to==g){
                    return true;
                }
            }
        }
    }
    return false;
}
</code></pre>
<h1 id="ワーシャルフロイド法"><a class="header" href="#ワーシャルフロイド法">ワーシャルフロイド法</a></h1>
<h2 id="概要-26"><a class="header" href="#概要-26">概要</a></h2>
<p>全ての頂点の組の最短距離が求められる．</p>
<h2 id="計算量-15"><a class="header" href="#計算量-15">計算量</a></h2>
<p>頂点数を$V$とすると$O(V^3)$．</p>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<p>行列でグラフを表現するが，同じ頂点同士の距離は0，辺が存在しない場合は距離を$\infty$とする．</p>
<h2 id="ソースコード-28"><a class="header" href="#ソースコード-28">ソースコード</a></h2>
<pre><code class="language-cpp">/*
Gは隣接行列である必要があり，辺がない場合はINF，自己ループ辺は0
*/
const long INF = 1e17;

vector&lt;vector&lt;long&gt;&gt; floydWarshall(vector&lt;vector&lt;long&gt;&gt; &amp;G){
    const int N = G.size();
    auto H = G;
    for(int a=0;a&lt;N;a++){
        for(int b=0;b&lt;N;b++){
            for(int c=0;c&lt;N;c++){
                long d = H[b][a] + H[a][c];
                if(H[b][a]==INF||H[a][c]==INF)d = INF;
                if(H[b][c] &gt; d){
                    H[b][c] = d;
                }
            }
        }
    }
    return H;
}

</code></pre>
<h1 id="二次元マップをグラフに起こすやつ"><a class="header" href="#二次元マップをグラフに起こすやつ">二次元マップをグラフに起こすやつ</a></h1>
<h2 id="概要-27"><a class="header" href="#概要-27">概要</a></h2>
<p>2次元<code>#.</code>マップをグラフに起こします．</p>
<h2 id="注意-1"><a class="header" href="#注意-1">注意</a></h2>
<p><code>calc()</code>関数内を適切に書き換えて使用してください．</p>
<h2 id="ソースコード-29"><a class="header" href="#ソースコード-29">ソースコード</a></h2>
<pre><code class="language-cpp">struct GridGraph{
    int H,W;
    Graph G;
    vector&lt;vector&lt;int&gt;&gt; A;
    vector&lt;long&gt; D;
    GridGraph(int h,int w){
        H = h;
        W = w;
        init();
    }
    void init(){
        D.clear();
        G.clear();
        A.clear();
        G.resize(H*W);
        A.resize(H);
        for(int i=0;i&lt;H;i++){
            A[i].resize(W);
        }
    }
    void in(){
        map&lt;char,int&gt; mp = {{'.',0},{'#',1}};
        for(int i=0;i&lt;H;i++){
            string S;cin&gt;&gt;S;
            for(int j=0;j&lt;W;j++){
                A[i][j] = mp[(S[j])];
            }
        }
    }
    void build(){
        static vector&lt;int&gt; dx = {1,0};
        static vector&lt;int&gt; dy = {0,1};
        for(int i=0;i&lt;H;i++){
            for(int j=0;j&lt;W;j++){
                for(int a=0;a&lt;(int)dx.size();a++){
                    int h = i + dy[a];
                    int w = j + dx[a];
                    if(h&lt;0||w&lt;0||h&gt;=H||w&gt;=W)continue;
                    if(A[h][w]==A[i][j]&amp;&amp;A[h][w]==0){
                        int x = toInt(i,j);
                        int y = toInt(h,w);
                        G[x].push_back({y,1});
                        G[y].push_back({x,1});
                    }
                }
            }
        }
    }
    void calc(int h,int w){
        //dijkstra(toInt(h,w),G,D);
    }
    int toInt(int h,int w){
        return W*h + w;
    }
    long getDis(int h,int w){
        return D[toInt(h,w)];
    }
};

</code></pre>
<h1 id="2部グラフ判定"><a class="header" href="#2部グラフ判定">2部グラフ判定</a></h1>
<h2 id="概要-28"><a class="header" href="#概要-28">概要</a></h2>
<p>2部グラフであるかを判定する．</p>
<h2 id="アルゴリズム"><a class="header" href="#アルゴリズム">アルゴリズム</a></h2>
<p>BFSで隣り合う頂点を異なる2色で塗っていき，最後に全ての隣り合う頂点が異なる色で塗られているかを判定する．計算量は$O(V+E)$</p>
<h2 id="ソースコード-30"><a class="header" href="#ソースコード-30">ソースコード</a></h2>
<pre><code class="language-cpp">struct Edge{
    int to;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;; //隣接グラフ


/*
ダイクストラ法
重みはlong型
始点s，グラフGの点をDに
*/
void bfs(int n,int pre,Graph &amp;G,vector&lt;int&gt;&amp;C){
    for(auto&amp;e:G[n]){
        if(C[e.to]!=-1)continue;
        C[e.to] = 1-C[n];
        bfs(e.to,n,G,C);
    }
}

int main(){
    int N,M;cin&gt;&gt;N&gt;&gt;M;
    Graph G(N);
    for(int i=0;i&lt;M;i++){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        u--;v--;
        G[u].push_back({v});
        G[v].push_back({u});
    }
    vector&lt;int&gt;C(N,-1);
    for(int i=0;i&lt;N;i++){
        if(C[i] != -1)continue;
        C[i]=0;
        bfs(i,-1,G,C);
    }
    bool ok = true;
    for(int i=0;i&lt;N;i++){
        //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;C[i]&lt;&lt;endl;
        for(auto&amp;e:G[i]){
            if(C[e.to] == C[i]){
                ok = false;
            }
        }
    }
    cout&lt;&lt;(ok?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl;
}
</code></pre>
<h1 id="n頂点n辺グラフ分析"><a class="header" href="#n頂点n辺グラフ分析">N頂点N辺グラフ分析</a></h1>
<h2 id="概要-29"><a class="header" href="#概要-29">概要</a></h2>
<p>連結な$N$頂点$N$辺無向グラフは閉路が必ず$1$つできる．
その一つの閉路を$O(N)$で求める．このようなグラフは俗になもりグラフと呼ばれる．</p>
<h2 id="ソースコード-31"><a class="header" href="#ソースコード-31">ソースコード</a></h2>
<p>自己ループには対応していない．</p>
<pre><code class="language-cpp">struct Edge{
    int to;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;;

void dfs(Graph&amp;G,int n,vector&lt;int&gt; &amp;pre,int &amp;x){
    for(Edge&amp;e:G[n]){
        if(e.to==pre[n])continue;
        if(pre[e.to]==-1){
            pre[e.to]=n;
            dfs(G,e.to,pre,x);
        }else{
            x = n;
        }
    }
}

vector&lt;int&gt; namori(Graph graph){
    //なもりグラフの閉路に含まれる頂点を返す
    int n=(int)graph.size();
    vector&lt;int&gt; res;
    vector&lt;int&gt; pre(n,-1);//前回の頂点
    int x=-1;
    dfs(graph,0,pre,x);
    cout&lt;&lt;x&lt;&lt;endl;
    if(x==-1)return res;
    int y=pre[x];
    while(x!=y){
        res.push_back(y);
        y=pre[y];
    }
    res.push_back(x);
    return res;
}
</code></pre>
<h1 id="木の直径"><a class="header" href="#木の直径">木の直径</a></h1>
<h2 id="概要-30"><a class="header" href="#概要-30">概要</a></h2>
<p>最も離れた$2$点の距離を木の直径と呼ぶ．頂点数を$V$とすると$O(V)$で求める．</p>
<h2 id="ソースコード-32"><a class="header" href="#ソースコード-32">ソースコード</a></h2>
<p>中身はDFSを2回するだけ．</p>
<pre><code class="language-cpp">struct Edge{
    int to;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;;

void dfs(Graph &amp;G,int v,int p,int d,vector&lt;int&gt;&amp;dist){
    dist[v]=d;
    for(auto&amp;e:G[v]){
        if(e.to==p)continue;
        dfs(G,e.to,v,d+1,dist);
    }
}

int treeDiameter(Graph &amp;Tree){
    int N = Tree.size();
    vector&lt;int&gt; dist(N,-1);
    dfs(Tree,0,-1,0,dist);
    int farthest = max_element(all(dist))-dist.begin();
    vector&lt;int&gt; dist2(N,-1);
    dfs(Tree,farthest,-1,0,dist2);
    return *max_element(all(dist2));
}
</code></pre>
<h1 id="level-ancestor"><a class="header" href="#level-ancestor">Level Ancestor</a></h1>
<h2 id="概要-31"><a class="header" href="#概要-31">概要</a></h2>
<p>根つき木で，前計算を行うことで，ある頂点の$x$個先の祖先，ある頂点で深さが$d$である祖先を高速に求める．</p>
<h2 id="計算量-16"><a class="header" href="#計算量-16">計算量</a></h2>
<p>頂点数を$N$とすると前計算$O(N\log N)$，各クエリ$O(\log N)$で動作．</p>
<h2 id="ソースコード-33"><a class="header" href="#ソースコード-33">ソースコード</a></h2>
<pre><code class="language-cpp">
struct Edge{
    int to;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;;

struct LA{
    Graph G;
    vector&lt;vector&lt;int&gt;&gt; ancestor;
    //ancestor[i][j]:=頂点iの2^j個親
    vector&lt;int&gt; depth;//深さ
    int N;
    int root = 0;
    const int maxDepth = 25;
    LA(int _N){
        this-&gt; N = _N;
        init();
    }
    void init(){
        G.resize(N);
        depth.resize(N);
        ancestor.resize(N);
        for(int i=0;i&lt;N;i++){
            ancestor[i].resize(maxDepth);
        }
    }
    void build(){
        ancestor[root][0] = root;
        bfs(root,0,0);
        for(int i=1;i&lt;maxDepth;i++){
            for(int j=0;j&lt;N;j++){
                ancestor[j][i] = ancestor[ancestor[j][i-1]][i-1];
            }
        }
    }
    void bfs(int n,int pre,int d){
        depth[n] = d;
        ancestor[n][0] = pre;
        for(auto&amp;E:G[n]){
            if(E.to==pre)continue;
            bfs(E.to,n,d+1);
        }
    }
    //頂点nのs個先の祖先
    int anc(int n,int s){
        for(int i=0;i&lt;maxDepth;i++){
            if(s&amp;(1&lt;&lt;i)){
                n = ancestor[n][i];
            }
        }
        return n;
    }
    //頂点nの深さs(root=0)の祖先
    int levelAnc(int n,int s){
        return anc(n,depth[n]-s);
    }
};
</code></pre>
<h1 id="lowest-common-ancestor"><a class="header" href="#lowest-common-ancestor">Lowest Common Ancestor</a></h1>
<h2 id="概要-32"><a class="header" href="#概要-32">概要</a></h2>
<p>2つの頂点について，それぞれの共通祖先のうち最も深いものを求める．</p>
<h2 id="計算量-17"><a class="header" href="#計算量-17">計算量</a></h2>
<p>前計算$O(N\log N)$，クエリ$O(\log N)$</p>
<h2 id="ソースコード-34"><a class="header" href="#ソースコード-34">ソースコード</a></h2>
<pre><code class="language-cpp">struct Edge{
    int to;
};

using Graph = vector&lt;vector&lt;Edge&gt;&gt;;

struct LA{
    Graph G;
    vector&lt;vector&lt;int&gt;&gt; ancestor;
    //ancestor[i][j]:=頂点iの2^j個親
    vector&lt;int&gt; depth;//深さ
    int N;
    int root = 0;
    const int maxDepth = 25;
    LA(int _N){
        this-&gt; N = _N;
        init();
    }
    void init(){
        G.resize(N);
        depth.resize(N);
        ancestor.resize(N);
        for(int i=0;i&lt;N;i++){
            ancestor[i].resize(maxDepth);
        }
    }
    void build(){
        ancestor[root][0] = root;
        bfs(root,0,0);
        for(int i=1;i&lt;maxDepth;i++){
            for(int j=0;j&lt;N;j++){
                ancestor[j][i] = ancestor[ancestor[j][i-1]][i-1];
            }
        }
    }
    void bfs(int n,int pre,int d){
        depth[n] = d;
        ancestor[n][0] = pre;
        for(auto&amp;E:G[n]){
            if(E.to==pre)continue;
            bfs(E.to,n,d+1);
        }
    }
    //頂点nのs個先の祖先
    int anc(int n,int s){
        for(int i=0;i&lt;maxDepth;i++){
            if(s&amp;(1&lt;&lt;i)){
                n = ancestor[n][i];
            }
        }
        return n;
    }
    //頂点nの深さs(root=0)の祖先
    int levelAnc(int n,int s){
        return anc(n,depth[n]-s);
    }
    //頂点a,bの共通最近祖先
    int lca(int a,int b){
        if(depth[a]&lt;depth[b])swap(a,b);
        a = levelAnc(a,depth[b]);//同じ深さにする
        if(a==b)return a;
        for(int k=maxDepth-1;k&gt;=0;k--){
            if(ancestor[a][k]!=ancestor[b][k]){
                a = ancestor[a][k];
                b = ancestor[b][k];
            }
        }
        return ancestor[a][0];
    }
};
</code></pre>
<h1 id="木の巡回"><a class="header" href="#木の巡回">木の巡回</a></h1>
<h2 id="概要-33"><a class="header" href="#概要-33">概要</a></h2>
<p>木の頂点に番号を振る．</p>
<h2 id="dfsの順"><a class="header" href="#dfsの順">DFSの順</a></h2>
<h3 id="ソースコード-35"><a class="header" href="#ソースコード-35">ソースコード</a></h3>
<pre><code class="language-cpp">//dfsの行きがけ順
void preorder(const Graph &amp;G,int n,int p,vector&lt;bool&gt;&amp;visited,vector&lt;int&gt;&amp;order){
    visited[n]=true;
    order.push_back(n);
    for(auto&amp;e:G[n]){
        if(e.to==p)continue;
        if(visited[e.to])continue;
        preorder(G,e.to,n,visited,order);
    }
}

//dfsの帰りがけ順
void postorder(const Graph &amp;G,int n,int p,vector&lt;bool&gt;&amp;visited,vector&lt;int&gt;&amp;order){
    visited[n]=true;
    for(auto&amp;e:G[n]){
        if(e.to==p)continue;
        if(visited[e.to])continue;
        postorder(G,e.to,n,visited,order);
    }
    order.push_back(n);
}
</code></pre>
<h2 id="bfsの順"><a class="header" href="#bfsの順">BFSの順</a></h2>
<h3 id="ソースコード-36"><a class="header" href="#ソースコード-36">ソースコード</a></h3>
<pre><code class="language-cpp"></code></pre>
<h1 id="オイラーツアー"><a class="header" href="#オイラーツアー">オイラーツアー</a></h1>
<h1 id="サイクル検出"><a class="header" href="#サイクル検出">❌サイクル検出</a></h1>
<h1 id="橋検出"><a class="header" href="#橋検出">❌橋検出</a></h1>
<h1 id="関節点検出"><a class="header" href="#関節点検出">❌関節点検出</a></h1>
<h1 id="01bfs"><a class="header" href="#01bfs">❌01BFS</a></h1>
<h1 id="strongly-connected-component"><a class="header" href="#strongly-connected-component">Strongly Connected Component</a></h1>
<h1 id="プリム法"><a class="header" href="#プリム法">プリム法</a></h1>
<h1 id="クラスカル法"><a class="header" href="#クラスカル法">クラスカル法</a></h1>
<h1 id="木dp"><a class="header" href="#木dp">❌木dp</a></h1>
<h1 id="全方位木dp"><a class="header" href="#全方位木dp">❌全方位木dp</a></h1>
<h1 id="重心分解"><a class="header" href="#重心分解">❌重心分解</a></h1>
<h1 id="最大流"><a class="header" href="#最大流">最大流</a></h1>
<h1 id="最小コスト"><a class="header" href="#最小コスト">最小コスト</a></h1>
<h1 id="未分類-1"><a class="header" href="#未分類-1">未分類</a></h1>
<h1 id="imos法"><a class="header" href="#imos法">imos法</a></h1>
<h2 id="概要-34"><a class="header" href="#概要-34">概要</a></h2>
<p>要素数$N$の数列について，区間への加算を$O(1)$で行い，$O(N)$の処理を行うことで各値が$O(1)$で得られる．</p>
<h2 id="ソースコード-37"><a class="header" href="#ソースコード-37">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct Imos{
    vector&lt;T&gt; A;
    int N;
    constexpr Imos(int N){
        this -&gt; N = N;
        init();
    }
    constexpr void init(){
        A.resize(N+1);
        fill(A.begin(),A.end(),0);
    }
    /*[l,r]にxを加算*/
    constexpr void add(int l,int r,T x){
        A[l] += x;
        A[r+1] += -x;
    }
    constexpr void calc(){
        for(int i=0;i&lt;N;i++){
            A[i+1] += A[i];
        }
    }
    constexpr T get(int i){
        return A[i];
    }
};
</code></pre>
<h1 id="2次元imos法"><a class="header" href="#2次元imos法">2次元imos法</a></h1>
<h2 id="概要-35"><a class="header" href="#概要-35">概要</a></h2>
<h2 id="ソースコード-38"><a class="header" href="#ソースコード-38">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct Imos2d{
    vector&lt;vector&lt;T&gt;&gt; A;
    int H,W;
    constexpr Imos2d(int H,int W){
        this-&gt;H = H;
        this-&gt;W = W;
        init();
    }
    constexpr void init(){
        A.resize(H+1);
        for(int i=0;i&lt;=H;i++){
            A[i].resize(W+1);
            fill(A[i].begin(),A[i].end(),0);
        }
    }
    /*四角形にxを加算*/
    constexpr void add(int ly,int lx,int ry,int rx,T x){
        A[ly][lx] += x;
        A[ry+1][lx] += -x;
        A[ly][rx+1] += -x;
        A[ry+1][rx+1] += x;
    }
    constexpr void calc(){
        for(int h=0;h&lt;=H;h++){
            for(int w=0;w&lt;W;w++){
                A[h][w+1] += A[h][w];
            }
        }
        for(int h=0;h&lt;H;h++){
            for(int w=0;w&lt;=W;w++){
                A[h+1][w] += A[h][w];
            }
        } 
    }
    constexpr T get(int y,int x){
        return A[y][x];
    }
};
</code></pre>
<h1 id="座標圧縮imos法"><a class="header" href="#座標圧縮imos法">座標圧縮imos法</a></h1>
<h2 id="ソースコード-39"><a class="header" href="#ソースコード-39">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; bool underElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = upper_bound(A.begin(),A.end(),x) - A.begin();
    index--;
    if(index &gt;= (int)A.size())return false;
    find = A[index];
    return true;
}

template&lt;class T&gt; struct shrinkImos{
    vector&lt;pair&lt;long,T&gt;&gt; query;
    vector&lt;pair&lt;long,T&gt;&gt; result;
    shrinkImos(){
        init();
    }
    void init(){
        query.clear();
        result.clear();
    }
    /*[l,r]にxを加算*/
    void add(int l,int r,T x){
        query.push_back({l,x});
        query.push_back({r,0});
        query.push_back({r+1,-x});
    }
    void calc(){
        result.clear();
        for(const auto&amp;[p,v]:query){
            result.push_back({p,v});
        }
        sort(result.begin(),result.end());
        for(int i=0;i&lt;(int)result.size()-1;i++){
            result[i+1].second += result[i].second;
        }
    }
    constexpr T get(long i){
        pair&lt;long,T&gt; f;
        int _;
        if(!underElement(result,i,f,_)){
            return 0;
        }
        return f.second;
    }
};
</code></pre>
<h1 id="座標圧縮2次元imos法"><a class="header" href="#座標圧縮2次元imos法">座標圧縮2次元imos法</a></h1>
<h2 id="ソースコード-40"><a class="header" href="#ソースコード-40">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; bool underElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = upper_bound(A.begin(),A.end(),x) - A.begin();
    index--;
    if(index &gt;= (int)A.size())return false;
    find = A[index];
    return true;
}

template&lt;class T1,class T2&gt; struct shrinkImos2d{
    vector&lt;T1&gt; Ay,Ax;
    vector&lt;tuple&lt;T1,T1,T2&gt;&gt; query;
    vector&lt;vector&lt;T2&gt;&gt; result;
    shrinkImos2d(){
        init();
    }
    void init(){
        Ax.push_back(2001002003);
        Ay.push_back(2001002003);
        /*
        Ax.push_back(1001002003004005006);
        Ay.push_back(1001002003004005006);
        */
        result.clear();
    }
    /*[l,r]にxを加算*/
    void add(T1 ly,T1 lx,T1 ry,T1 rx,T2 x){
        Ay.push_back(ly);
        Ay.push_back(ry);
        Ay.push_back(ry+1);
        Ax.push_back(lx);
        Ax.push_back(rx);
        Ax.push_back(rx+1);
        query.push_back({ly,lx,x});
        query.push_back({ry+1,lx,-x});
        query.push_back({ly,rx+1,-x});
        query.push_back({ry+1,rx+1,x});
    }
    void calc(){
        result.clear();
        sort(Ax.begin(),Ax.end());
        sort(Ay.begin(),Ay.end());
        Ax.erase(unique(Ax.begin(), Ax.end()), Ax.end());
        Ay.erase(unique(Ay.begin(), Ay.end()), Ay.end());
        
        result.resize(Ay.size());
        for(int i=0;i&lt;(int)Ay.size();i++){
            result[i].resize(Ax.size());
            fill(result[i].begin(),result[i].end(),0);
        }
        for(const auto&amp;[y,x,a]:query){
            int yi = lower_bound(Ay.begin(),Ay.end(),y)-Ay.begin();
            int xi = lower_bound(Ax.begin(),Ax.end(),x)-Ax.begin();
            result[yi][xi] += a;
        }
        for(int y=0;y&lt;(int)result.size();y++){
            for(int x=0;x&lt;(int)result[y].size()-1;x++){
                result[y][x+1] += result[y][x];
            }
        }
        for(int y=0;y&lt;(int)result.size()-1;y++){
            for(int x=0;x&lt;(int)result[y].size();x++){
                result[y+1][x] += result[y][x];
            }
        }
    }
    constexpr T2 get(T1 y,T1 x){
        T1 yf,xf;
        int yi,xi;
        bool a = underElement(Ay,y,yf,yi);
        bool b = underElement(Ax,x,xf,xi);
        if(a||b)return 0;
        return result[yi][xi];
    }
    constexpr long area(T1 iy,T1 ix){
        return (long)(Ax[ix+1]-Ax[ix])*(long)(Ay[iy+1]-Ay[iy]);
    }
    void print(){
        for(int i=0;i&lt;(int)Ax.size();i++){
            cout&lt;&lt;Ax[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
        for(int i=0;i&lt;(int)Ay.size();i++){
            cout&lt;&lt;Ay[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
        for(int y=0;y&lt;(int)result.size();y++){
            for(int x=0;x&lt;(int)result[y].size();x++){
                cout &lt;&lt; result[y][x] &lt;&lt;&quot; &quot;;
            }
            cout&lt;&lt;endl;
        }
    }
};
</code></pre>
<h1 id="累積和"><a class="header" href="#累積和">累積和</a></h1>
<h2 id="概要-36"><a class="header" href="#概要-36">概要</a></h2>
<p>静的な数列の区間和を高速で求める．</p>
<h2 id="計算量-18"><a class="header" href="#計算量-18">計算量</a></h2>
<ul>
<li>構築: $O(N)$</li>
<li>クエリ：$O(1)$</li>
</ul>
<h2 id="ソースコード-41"><a class="header" href="#ソースコード-41">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct CumulativeSum{
    size_t n;
    vector&lt;T&gt; A;
    CumulativeSum(size_t n){
        this-&gt;n=n;
        init();
    };
    void init(){
        A.resize(n+1);
    }
    void add(int i,T x){
        A[i+1]=x;
    }
    void build(){
        for(int i=0;i&lt;n;i++){
            A[i+1]+=A[i];
        }
    }
    /*[l,r)の総和を求める*/
    T query(int l,int r){
        return A[r]-A[l];
    }
};
</code></pre>
<h1 id="2次元累積和"><a class="header" href="#2次元累積和">2次元累積和</a></h1>
<h2 id="概要-37"><a class="header" href="#概要-37">概要</a></h2>
<p>$H$行$W$列の行列があり，各要素を$A_{ij}$とする．このとき，前処理を行うことで，次の値を$O(1)$で求めることができる．
$$
\sum_{h_1\leq i&lt; h_2}\sum_{w_1\leq j&lt;w_2} A_{ij}
$$</p>
<h2 id="計算量-19"><a class="header" href="#計算量-19">計算量</a></h2>
<ul>
<li>構築: $O(HW)$</li>
<li>クエリ: $O(1)$</li>
</ul>
<h2 id="ソースコード-42"><a class="header" href="#ソースコード-42">ソースコード</a></h2>
<pre><code class="language-cpp">template&lt;class T&gt; struct CumulativeSum2D{
    size_t H,W;
    vector&lt;vector&lt;T&gt;&gt;data,A;
    CumulativeSum2D(size_t H,size_t W){
        this-&gt;H=H;
        this-&gt;W=W;
        data.resize(H+1,vector&lt;T&gt;(W+1,0));
        A.resize(H+1,vector&lt;T&gt;(W+1,0));
    }
    void add(size_t h,size_t w,T x){
        A[h][w]+=x;
    }
    void build(){
        int H=A.size();
        int W=A[0].size();
        data=vector&lt;vector&lt;T&gt;&gt;(H+1,vector&lt;T&gt;(W+1,0));
        rep(i,H){
            rep(j,W){
                data[i+1][j+1]=A[i][j];
            }
        }
        rep(i,H+1){
            rep(j,W){
                data[i][j+1]+=data[i][j];
            }
        }
        rep(i,H){
            rep(j,W+1){
                data[i+1][j]+=data[i][j];
            }
        }
    }
    /*w1&lt;=x&lt;w2, h1&lt;=y&lt;h2*/
    T sum(int h1,int w1,int h2,int w2){
        return data[h2][w2]-data[h1][w2]-data[h2][w1]+data[h1][w1];
    }
};
</code></pre>
<h1 id="要素を2分探索"><a class="header" href="#要素を2分探索">要素を2分探索</a></h1>
<h2 id="概要-38"><a class="header" href="#概要-38">概要</a></h2>
<p>C++には<code>lower_bound</code>や<code>upper_bound</code>，<code>binary_search</code>が用意されているが，例外処理が面倒なので関数したもの．
次の関数を作成した．</p>
<ul>
<li>その数が存在するかの<code>isExist</code></li>
<li>$x$以上の最小の数を探す<code>lowerElement</code></li>
<li>$x$より大きい最小の数を探す<code>upperlement</code></li>
<li>$x$以下の最大の数を探す<code>underElement</code></li>
<li>$x$未満の最大の数を探す<code>lessElement</code></li>
<li>$x$の個数を数える<code>countElement</code></li>
<li>$l$以上$r$以下の個数を数える<code>countElementInRange</code></li>
</ul>
<h2 id="注意-2"><a class="header" href="#注意-2">注意</a></h2>
<p><code>vector</code>はソート済みである必要がある．</p>
<h2 id="ソースコード-43"><a class="header" href="#ソースコード-43">ソースコード</a></h2>
<pre><code class="language-cpp">/*
Aにxが存在するか
O(log N)
*/
template&lt;class T&gt; bool isExist(vector&lt;T&gt; &amp;A,T x){
    return binary_search(A.begin(),A.end(),x);
}
template&lt;class T&gt; bool isExist(set&lt;T&gt; &amp;A,T x){
    auto it = A.lower_bound(x);
    if(it==A.end()){
        return false;
    }
    return *it == x;
}

/*
Aに存在するx以上の数
最も小さいindexとその値find
O(log N)
*/
template&lt;class T&gt; bool lowerElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = lower_bound(A.begin(),A.end(),x) - A.begin();
    if(index == (int)A.size())return false;
    find = A[index];
    return true;
}
template&lt;class T&gt; bool lowerElement(set&lt;T&gt; &amp;A,T x,T &amp;find){
    auto it = A.lower_bound(x);
    if(it==A.end())return false;
    find = *it;
    return true;
}



/*
Aに存在するxより大きい数
最も小さいindexとその値find
O(log N)
*/
template&lt;class T&gt; bool upperElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = upper_bound(A.begin(),A.end(),x) - A.begin();
    if(index == (int)A.size())return false;
    find = A[index];
    return true;
}
template&lt;class T&gt; bool upperElement(set&lt;T&gt; &amp;A,T x,T &amp;find){
    auto it = A.upper_bound(x);
    if(it == A.end())return false;
    find = *it;
    return true;
}               




/*
Aに存在するx以下
最も大きいindexとその値find
O(log N)
*/
template&lt;class T&gt; bool underElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = upper_bound(A.begin(),A.end(),x) - A.begin();
    index--;
    if(index &gt;= (int)A.size())return false;
    find = A[index];
    return true;
}
template&lt;class T&gt; bool underElement(set&lt;T&gt; &amp;A,T x,T &amp;find){
    auto it = A.upper_bound(x);
    if(it == A.begin())return false;
    it--;
    find = *it;
    return true;
}

/*
Aに存在するxより小さい数
最も大きいindexとその値find
O(log N)
*/
template&lt;class T&gt; bool lessElement(vector&lt;T&gt; &amp;A,T x,T &amp;find,int &amp;index){
    index = lower_bound(A.begin(),A.end(),x) - A.begin();
    index--;
    if(index &lt; 0)return false;
    find = A[index];
    return true;
}
template&lt;class T&gt; bool lessElement(set&lt;T&gt; &amp;A,T x,T &amp;find){
    auto it = A.lower_bound(x);
    if(it == A.begin())return false;
    it--;
    find = *it;
    return true;
}

/*
Aに含まれるxの個数をO(log N)で求める
*/
template&lt;class T&gt; int countElement(vector&lt;T&gt; &amp;A,T x){
    T f1,f2;
    int i1,i2;
    lowerElement(A,x,f1,i1);
    underElement(A,x,f2,i2);
    return isExist(A,x)?i2-i1+1:0;
}

/*
Aに含まれるl以上r以下の個数をO(log N)で求める
*/
template&lt;class T&gt; int countElementInRange(vector&lt;T&gt; &amp;A,T l,T r){
    T f1,f2;
    int i1,i2;
    lowerElement(A,l,f1,i1);
    underElement(A,r,f2,i2);
    int c = i2-i1+1;
    return c&gt;0?c:0;
}

</code></pre>
<h1 id="日付計算"><a class="header" href="#日付計算">日付計算</a></h1>
<h2 id="曜日計算"><a class="header" href="#曜日計算">曜日計算</a></h2>
<pre><code class="language-cpp">/*曜日計算*/
int wday(int y,int m,int d){
    if(m==1||m==2){
        m+=12;
        y--;
    }
    return (y+y/4-y/100+y/400+(13*m+8)/5+d)%7;
    //0,1,2,...日,月,火
}
</code></pre>
<h2 id="経過日数"><a class="header" href="#経過日数">経過日数</a></h2>
<p>1年1月1日からの経過日数</p>
<pre><code class="language-cpp">/*1年1月1日からの経過日数(1年1月1日が0日目)*/
int days(int y,int m,int d){
    if(m==1||m==2){
        m+=12;
        y--;
    }
    return 365*y+y/4-y/100+y/400+(306*(m+1))/10+d-429;
}
</code></pre>
<h1 id="mex関数"><a class="header" href="#mex関数">Mex関数</a></h1>
<h1 id="mos-algorithm"><a class="header" href="#mos-algorithm">❌Mo's algorithm</a></h1>
<h1 id="有名問題"><a class="header" href="#有名問題">有名問題</a></h1>
<h1 id="転倒数計算"><a class="header" href="#転倒数計算">転倒数計算</a></h1>
<h2 id="問題"><a class="header" href="#問題">問題</a></h2>
<ul>
<li>問題リンク：<a href="https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_j">転倒数</a></li>
<li>転倒数とは，配列の中で，ある要素の前にある要素の値が大きいものの個数のこと
<ul>
<li>厳密には，長さ$N$の数列$A_1,A_2,A_3,\cdots,A_N$で，$i&lt;j$で$A_i&gt;A_j$となる$(i,j)$の個数</li>
</ul>
</li>
<li>あるいは，バブルソートを行ったときに，要素の交換回数のこと</li>
</ul>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>実際にバブルソートをすると要素数$N$で$O(N^2)$かかってしまうが，転倒数を計算するだけなら$1$点加算と区間和の取得ができるデータ構造BITやセグ木を用いて$O(N\log N)$で計算できる．</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct RSQ{
    int n;
    vector&lt;T&gt;dat;
    const T ZERO;
    RSQ(int n_,T ZERO_):ZERO(ZERO_){
        n=1;
        while(n&lt;n_)n*=2;
        //完全二分木にする
        dat.assign(2*n-1,ZERO);
    }
    void update(int k,T a){
        k+=n-1;// i番目は、配列上では n-1+i 番目に格納されている
        dat[k]+=a;// 葉の更新
        while(k&gt;0){
            k=(k-1)/2; //親のインデックス
            // 子の和を計算
            dat[k]=dat[k*2+1]+dat[k*2+2];
        }
    }
    
    T query(int a,int b,int k,int l,int r){
        if(r&lt;=a||b&lt;=l)return ZERO;//範囲外
        if(a&lt;=l&amp;&amp;r&lt;=b)return dat[k]; //範囲内である
        else{
            T vl=query(a,b,k*2+1,l,(l+r)/2);
            T vr=query(a,b,k*2+2,(l+r)/2,r);
            return vl+vr;
        }
    }
    //[a,b)の総和を求める
    T query(int a,int b){
        return query(a,b,0,0,n);
    }
};


int main(void){
    /*転倒数計算*/
    int n;cin&gt;&gt;n;
    vector&lt;int&gt;A(n);
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;A[i];
        A[i]--;
    }
    RSQ&lt;int&gt;rsq(n,0);
    long ans=0;
    for(int i=0;i&lt;n;i++){
        ans+=rsq.query(A[i]+1,n);
        rsq.update(A[i],1);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
<p><a href="https://atcoder.jp/contests/chokudai_S001/submissions/35410016">提出リンク</a></p>
<h1 id="包除原理"><a class="header" href="#包除原理">包除原理</a></h1>
<h2 id="簡単な例"><a class="header" href="#簡単な例">簡単な例</a></h2>
<p>$f(X)$を集合$X$の大きさとすると，
$$
f(A\cup B)= f(A) + f(B) -f(A\cap B)
$$
が成り立つ．これを一般化したものが包除原理．</p>
<h2 id="例題"><a class="header" href="#例題">例題</a></h2>
<p><a href="https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_be">問題リンク</a></p>
<ul>
<li>正の整数$N$と$A_1,A_2,A_3,\cdots,A_K$が与えられる</li>
<li>$1\leq K \leq 10$</li>
<li>$1\leq N \leq 10^{12}$</li>
<li>$1$以上$N$以下の整数で$A_1,A_2,A_3,\cdots,A_K$のいずれかの倍数であるものの個数を求める．</li>
</ul>
<p>言い換えると，$A_1$の倍数，$A_2$の倍数，$A_3$の倍数，$\cdots$，$A_K$の倍数，の$K$個の集合の和集合の大きさを求める．この$K$個の集合から$1$つ以上を選ぶ全ての組み合わせについて，</p>
<ul>
<li>奇数個の集合であれば，積集合の大きさを足す</li>
<li>偶数個の集合であれば，積集合の大きさを引く</li>
</ul>
<p>を行っていくと，最終的には辻褄が合って，条件を1つ以上満たすものの個数が求まる．</p>
<pre><code class="language-cpp">long GCD(long a,long b){
    if(a&lt;b)return GCD(b,a);
    if(b==0)return a;
    return GCD(b,a%b);
}
long LCM(long a,long b){
    return (a/GCD(a,b))*b;
}
int main(void){
    long N,K;cin&gt;&gt;N&gt;&gt;K;
    vector&lt;long&gt; V(K);
    rep(i,K)cin&gt;&gt;V[i];
    long ans = 0;
    for(int i=1;i&lt;(1&lt;&lt;K);i++){
        int c=0;
        long lcm=1;
        for(int k=0;k&lt;K;k++){
            if(i&amp;(1&lt;&lt;k)){
                c++;
                lcm = LCM(V[k],lcm);
            }
        }
        ans += (N/lcm) * (c%2==1?1L:-1L);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
<h1 id="線形漸化式"><a class="header" href="#線形漸化式">線形漸化式</a></h1>
<p>線形漸化式の第$n$項を求める様々な方法を紹介する．
ここでは例として，代表的な線形漸化式であるフィボナッチ数列の第$n$項を$\mod 10^9$で求めることにする．計算量は，$k$項間の線形漸化式の場合のものを示す．</p>
<h2 id="愚直"><a class="header" href="#愚直">愚直</a></h2>
<p>第$3$項，第$4$項，第$5$項と定義通り順に求めていく方法．計算量は$O(kn)$．
第$n$項までの全ての項の値がほしいときに有効である．</p>
<pre><code class="language-cpp">long N;cin&gt;&gt;N;
vector&lt;mint&gt; fibo={1,1};
for(int i=3;i&lt;=N;i++){
    int a = (int)fibo.size();
    fibo.push_back(fibo[a-1]+fibo[a-2]);
}
cout&lt;&lt;fibo.back()&lt;&lt;endl;
</code></pre>
<h2 id="行列累乗"><a class="header" href="#行列累乗">行列累乗</a></h2>
<p>ダブリングの考え方によって，$O(k^3\log n)$で求まる．
行列の掛け算自体がコストが高く，$k$が大きいときに時間がかかる．</p>
<pre><code class="language-cpp">long N;cin&gt;&gt;N;
Matrix&lt;mint&gt; mat(2,2);
mat[0][0] = 1;
mat[0][1] = 1;
mat[1][0] = 1;
mat[1][1] = 0;
auto ans = pow(mat,N-1);
cout&lt;&lt;ans[0][0]&lt;&lt;endl;
</code></pre>
<h2 id="きたまさ法"><a class="header" href="#きたまさ法">きたまさ法</a></h2>
<p>これもダブリングである．
計算量は，$O(k^2\log n)$である．
<a href="https://outline.hatenadiary.jp/entry/2020/07/02/205628">参考</a>(誤植がある気がする)</p>
<p>$k$項漸化式版は<a href="https://atcoder.jp/contests/tdpc/submissions/35257624">こちら</a>．</p>
<pre><code class="language-cpp">
vector&lt;mint&gt; kitamasa(long n,const vector&lt;mint&gt;&amp;d,const int k){
    //f(n)の係数ベクトルを求める．
    if(n==k){
        return d;
    }
    if(n&amp;1||n&lt;k*2){
        vector&lt;mint&gt; res(k);
        auto x1 = kitamasa(n-1,d,k);
        for(int i=0;i&lt;k;i++){
            res[i] = d[i]*x1[k-1] + (i&gt;0?x1[i-1]:0);
        }
        return res;
    }else{
        vector&lt;mint&gt; res(k,0);
        auto x0 = kitamasa(n/2,d,k);
        auto x1 = x0;
        for(int l=0;l&lt;k;l++){//f(n/2+l)
            for(int j=0;j&lt;k;j++){
                res[j] += x0[l]*x1[j];
            }
            vector&lt;mint&gt; next(k);
            for(int i=0;i&lt;k;i++){
                next[i] = d[i]*x1[k-1] + (i&gt;0?x1[i-1]:0);
            }
            swap(x1,next);
        }
        return res;
    }
}

int main(){
    vector&lt;mint&gt; d = {1,1};
    auto a = kitamasa(N-1,d,2);//N-1が2以下だと壊れる
    cout&lt;&lt;a[0]*d[0]+a[1]*d[1]&lt;&lt;endl;
}
</code></pre>
<h1 id="ヒストグラムの最大長方形"><a class="header" href="#ヒストグラムの最大長方形">❌ヒストグラムの最大長方形</a></h1>
<h1 id="スライド最小値"><a class="header" href="#スライド最小値">❌スライド最小値</a></h1>
<h1 id="写像12相"><a class="header" href="#写像12相">❌写像12相</a></h1>
<h1 id="ポリアの数え上げ定理"><a class="header" href="#ポリアの数え上げ定理">❌ポリアの数え上げ定理</a></h1>
<h1 id="longest-increase-subsequence"><a class="header" href="#longest-increase-subsequence">Longest Increase Subsequence</a></h1>
<h1 id="longest-common-subsequence"><a class="header" href="#longest-common-subsequence">Longest Common Subsequence</a></h1>
<h1 id="ナップザック問題"><a class="header" href="#ナップザック問題">ナップザック問題</a></h1>
<h1 id="巡回セールスマン問題"><a class="header" href="#巡回セールスマン問題">巡回セールスマン問題</a></h1>
<h1 id="燃やす埋める問題"><a class="header" href="#燃やす埋める問題">❌燃やす埋める問題</a></h1>
<h1 id="牛ゲー"><a class="header" href="#牛ゲー">❌牛ゲー</a></h1>
<h1 id="最長回文"><a class="header" href="#最長回文">❌最長回文</a></h1>
<h1 id="past"><a class="header" href="#past">PAST</a></h1>
<h1 id="第1回アルゴリズム検定"><a class="header" href="#第1回アルゴリズム検定">第1回アルゴリズム検定</a></h1>
<p><a href="https://atcoder.jp/contests/past201912-open">第一回 アルゴリズム実技検定</a></p>
<h2 id="a---2倍チェック"><a class="header" href="#a---2倍チェック">A - 2倍チェック</a></h2>
<p>各文字数字であるかをチェックする．数字以外が一つでもあったらエラー．</p>
<pre><code class="language-cpp">int main() {
    string S;cin&gt;&gt;S;
    bool error=false;
    for(int i=0;i&lt;3;i++){
        if(S[i]&lt;'0'||'9'&lt;S[i])error=true;
    }
    if(error){
        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;
    }else{
        cout&lt;&lt;stoi(S)*2&lt;&lt;endl;
    }
}
</code></pre>
<h2 id="b---増減管理"><a class="header" href="#b---増減管理">B - 増減管理</a></h2>
<p>問題文の通りに実装するだけ．</p>
<pre><code class="language-cpp">int main(void){
    int N;cin&gt;&gt;N;
    vector&lt;int&gt;A(N);
    rep(i,N)cin&gt;&gt;A[i];
    rep(i,N-1){
        int d=abs(A[i]-A[i+1]);
        if(A[i]==A[i+1])cout&lt;&lt;&quot;stay&quot;&lt;&lt;endl;
        if(A[i]&lt;A[i+1])cout&lt;&lt;&quot;up &quot;&lt;&lt;d&lt;&lt;endl;
        if(A[i]&gt;A[i+1])cout&lt;&lt;&quot;down &quot;&lt;&lt;d&lt;&lt;endl;
    }
}
</code></pre>
<h2 id="c---3番目"><a class="header" href="#c---3番目">C - 3番目</a></h2>
<p>ソートすれば楽．</p>
<pre><code class="language-cpp">int main(void){
    vector&lt;int&gt; A(6);
    rep(i,6)cin&gt;&gt;A[i];
    sort(all(A));
    cout&lt;&lt;A[3]&lt;&lt;endl;
}
</code></pre>
<h2 id="d---重複検査"><a class="header" href="#d---重複検査">D - 重複検査</a></h2>
<p>添字に注意して実装する．</p>
<pre><code class="language-cpp">int main(void){
    int N;cin&gt;&gt;N;
    vector&lt;int&gt; A(N+1,0);
    bool c=true;
    int d=0;
    rep(i,N){
        int a;cin&gt;&gt;a;
        A[a]++;
        if(A[a]==2){
            d=a;
            c=false;
        }
    }
    int n=0;
    rep(i,N)if(A[i+1]==0)n=i+1;
    if(c){
        cout&lt;&lt;&quot;Correct&quot;&lt;&lt;endl;
    }else{
        cout&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;endl;
    }
}

</code></pre>
<h2 id="e---snsのログ"><a class="header" href="#e---snsのログ">E - SNSのログ</a></h2>
<p>問題文の通りに丁寧に実装する．
コードが汚い．</p>
<pre><code class="language-cpp">int main(void){
    int N;cin&gt;&gt;N;
    int Q;cin&gt;&gt;Q;
    vector&lt;vector&lt;bool&gt;&gt; F(N,vector&lt;bool&gt;(N,false));
    rep(i,Q){
        vector&lt;vector&lt;bool&gt;&gt; F2(N,vector&lt;bool&gt;(N,false));
        int t;cin&gt;&gt;t;
        if(t==1){
            int a,b;cin&gt;&gt;a&gt;&gt;b;
            a--;b--;
            F2[a][b]=true;
        }else if(t==2){
            int a;cin&gt;&gt;a;a--;
            for(int k=0;k&lt;N;k++){
                if(F[k][a]){
                    F2[a][k]=true;
                }
            }
        }else if(t==3){
            int a;cin&gt;&gt;a;a--;
            for(int k=0;k&lt;N;k++){
                if(F[a][k]){
                    for(int l=0;l&lt;N;l++){
                        if(F[k][l]&amp;&amp;l!=a){
                            F2[a][l]=true;
                        }
                    }
                }
            }
        }
        for(int i=0;i&lt;N;i++){
            for(int k=0;k&lt;N;k++){
                F[i][k]=F[i][k]||F2[i][k];
            }
        }
    }
    for(int i=0;i&lt;N;i++){
        for(int k=0;k&lt;N;k++){
            cout&lt;&lt;(F[i][k]?&quot;Y&quot;:&quot;N&quot;);
        }
        cout&lt;&lt;endl;
    }
}
</code></pre>
<h2 id="f---doublecamelcase-sort"><a class="header" href="#f---doublecamelcase-sort">F - DoubleCamelCase Sort</a></h2>
<p>問題文の通りに実装する．</p>
<pre><code class="language-cpp">int main(void){
    string S;cin&gt;&gt;S;
    vector&lt;pair&lt;string,string&gt;&gt; T(0);
    string tmp=&quot;&quot;;
    tmp.push_back(S[0]);
    for(int i=1;i&lt;S.size();i++){
        tmp.push_back(S[i]);
        if('A'&lt;=S[i]&amp;&amp;S[i]&lt;='Z'){
            string tmp2=&quot;&quot;;
            for(char&amp;c:tmp){
                if('A'&lt;=c&amp;&amp;c&lt;='Z')tmp2.push_back(c-'A'+'a');
                else tmp2.push_back(c);
            }
            T.push_back({tmp2,tmp});
            i++;
            tmp=&quot;&quot;;
            tmp.push_back(S[i]);
        }
    }
    sort(all(T));
    for(auto&amp;t:T)cout&lt;&lt;t.second;
    cout&lt;&lt;endl;
}
</code></pre>
<h2 id="g---組分け"><a class="header" href="#g---組分け">G - 組分け</a></h2>
<p>$3^10$があまり大きくないので，$3^10$通り全探索する．答えがマイナスになるパターンがあるので注意．</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; permutation(int N,int U,bool h=false){
    //0,1,2,3,...,N-1のN個からU個選ぶ順列
    vector&lt;vector&lt;int&gt;&gt; A(0);
    auto fun = [&amp;h,&amp;A,&amp;N,&amp;U](auto &amp;fun,vector&lt;int&gt; &amp;B)-&gt;void{
        if((int)B.size()==U){
            auto C=B;
            do{
                A.push_back(C);
            }while(next_permutation(C.begin(),C.end()));
            return;
        }
        int s = (h?0:-1);
        if(!B.empty())s = B.back();
        for(int x=s+(h?0:1);x&lt;N;x++){
            B.push_back(x);
            fun(fun,B);
            B.pop_back();
        }
    };
    vector&lt;int&gt; C={};
    fun(fun,C);
    return A;
}

int main(void){
    int N;cin&gt;&gt;N;
    vector&lt;vector&lt;long&gt;&gt; A(N,vector&lt;long&gt;(N));
    for(int b=0;b&lt;N;b++){
        for(int a=b+1;a&lt;N;a++){
            cin&gt;&gt;A[a][b];
        }
    }
    auto B = permutation(3,N,true);
    long ans = -INFl;
    for(auto &amp;C:B){
        long s = 0;
        for(int b=0;b&lt;N;b++){
            for(int a=b+1;a&lt;N;a++){
                if(C[a]==C[b]){
                    s += A[a][b];
                }
            }
        }
        chmax(ans,s);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
<h2 id="h---まとめ売り"><a class="header" href="#h---まとめ売り">H - まとめ売り</a></h2>
<p>全種類販売をするとき，1番カードの残りが少ないものよりも$a$が大きければ販売することができる．
そうでなければ販売できない．よって，常に1番カードの残りが少ないものを記録しておけば良い．</p>
<pre><code class="language-cpp">int main(void){
    long N;cin&gt;&gt;N;
    vector&lt;long&gt;C(N);cin&gt;&gt;C;
    int Q;cin&gt;&gt;Q;
    long cnt = 0;
    long odd = 0,sum = 0;
    long minOdd = INFl,minEven = INFl;
    rep(i,N){
        if(i%2==1){//偶数
            chmin(minEven,C[i]);
        }else{
            chmin(minOdd,C[i]);
        }
    }
    rep(i,Q){
        int t;cin&gt;&gt;t;
        if(t==1){
            long x,a;cin&gt;&gt;x&gt;&gt;a;
            x--;
            if(x%2==0){//奇数
                if(C[x]-odd-sum-a&gt;=0){
                    C[x]-=a;
                    cnt+=a;
                    chmin(minOdd,C[x]);
                }
            }else{
                if(C[x]-sum-a&gt;=0){
                    C[x]-=a;
                    cnt+=a;
                    chmin(minEven,C[x]);
                }
            }
        }else if(t==2){
            long a;cin&gt;&gt;a;
            if(minOdd-odd-sum-a&gt;=0){
                odd+=a;
                cnt+=a*((N+1)/2);
            }
        }else if(t==3){
            long a;cin&gt;&gt;a;
            if(minOdd-odd-sum-a&gt;=0 &amp;&amp; minEven-sum-a&gt;=0){
                sum+=a;
                cnt+=a*N;
            }
        }
    }
    cout&lt;&lt;cnt&lt;&lt;endl;
}

</code></pre>
<h2 id="i---部品調達"><a class="header" href="#i---部品調達">I - 部品調達</a></h2>
<p>bitDPの問題．</p>
<pre><code class="language-cpp">int main(void){
    int N,M;cin&gt;&gt;N&gt;&gt;M;
    vector&lt;int&gt; S(M,0);
    vector&lt;long&gt; C(M);
    rep(i,M){
        string s;cin&gt;&gt;s;
        for(auto&amp;c:s){
            S[i]&lt;&lt;=1;
            S[i]|=(c=='Y');
        }
        cin&gt;&gt;C[i];
    }
    vector&lt;vector&lt;long&gt;&gt; dp(M+1,vector&lt;long&gt;(1&lt;&lt;N,INFl));
    //dp[a][b] := a番目まで集合bを得るコストの最小値
    dp[0][0] = 0;
    for(int a=0;a&lt;M;a++){
        for(int b=0;b&lt;(1&lt;&lt;N);b++){
            chmin(dp[a+1][b],dp[a][b]);
            chmin(dp[a+1][b|S[a]],dp[a][b]+C[a]);
        }
    }
    auto ans = dp[M][(1&lt;&lt;N)-1];
    if(ans==INFl)ans=-1;
    cout&lt;&lt;ans&lt;&lt;endl;
}

</code></pre>
<h2 id="j---地ならし"><a class="header" href="#j---地ならし">J - 地ならし</a></h2>
<p>一見面倒な探索問題だが，$O((HW)^3)$でも間に合うことに甘えて愚直実装をする．</p>
<pre><code class="language-cpp">int main(void){
    int H,W;cin&gt;&gt;H&gt;&gt;W;
    vector&lt;vector&lt;long&gt;&gt;A(H+2,vector&lt;long&gt;(W+2,INFl));
    rep(i,H){
        rep(j,W){
            cin&gt;&gt;A[i+1][j+1];
        }
    }
    vector&lt;vector&lt;long&gt;&gt; BL(H+2,vector&lt;long&gt;(W+2,INFl));
    vector&lt;vector&lt;long&gt;&gt; BR(H+2,vector&lt;long&gt;(W+2,INFl));
    vector&lt;vector&lt;long&gt;&gt; UR(H+2,vector&lt;long&gt;(W+2,INFl));
    vector&lt;int&gt; dy={1,-1,0,0};
    vector&lt;int&gt; dx={0,0,1,-1};
    BL[H][1]=BR[H][W]=UR[1][W]=0;
    rep(_,H*W){
        rep1(i,H){
            rep1(j,W){
                rep(k,4){
                    chmin(BL[i][j],BL[i+dy[k]][j+dx[k]]+A[i][j]);
                    chmin(BR[i][j],BR[i+dy[k]][j+dx[k]]+A[i][j]);
                    chmin(UR[i][j],UR[i+dy[k]][j+dx[k]]+A[i][j]);
                }
            }
        }
    }
    long ans = INFl;
    rep1(i,H){
        rep1(j,W){
            chmin(ans,BL[i][j]+BR[i][j]+UR[i][j]-2*A[i][j]);
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
<h2 id="k---巨大企業"><a class="header" href="#k---巨大企業">K - 巨大企業</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
